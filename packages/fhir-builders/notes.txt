The idea here is to create a bunch of helper functions to make it easy to create fhir data structures

```
patient(id)
  .name({text: fullName, use 'official'})
  .name({text: fullName, use 'official'})
  .address(blah)
```

A couple of problems

1. The builder function (name) and the actual data key (name) are often the same

The only way I think to resolve this is to use a proxy of some kind and make the data ejectable

toString() and toJSON() and serialize() will return the inner object. 

but it really really bugs me.

I want you to be able to just use native fetch to post the object without any inner transformation

Is there any way in javascript to get and set with one key name, but to invoke on another?

Maybe I need AI for this after all.


2. I need to work out how to assert strong typings. The mixins pattern is a bit flexbile - I need patient() to have a really strong api (and I don't want that to be hard to define in ts)

3. The constrcutor/factory pattern isn't right at the moment

## Versions

how will I suppose differnt fhir versions?


One way would be to implement version 1, then have subclasses which extend and override 

could be a lot of work


How much difference is there across versions? Here you go, there's a diff page: https://hl7.org/fhir/R5/diff.html

Ok and it is immediately obvious that the list of differences here is huge. But I suppose you only have to look at CHANGED and maybe REMOVED things. When downgrading, you would remove anything newly added. When upgrading, you would remove anything removed and move/rename/port anything changed. That is a much smaller list I think

Ok so here's my dream API:

```
patient({}, '4') // this will create a v4 patient
  .toVersion('5') // this will auto migrate the patient to v5
```

The builders natively understand versions

One nice thing about this API is I can take a v4 object, pass it into the constructor, and spit out a version

But what's also true is that creating all this is a massive full time effort, and I don't really think AI can help me.

What can I test on?

Patient has only one small change, which is a default value

Contract might be an interesting one to migrate - term.action.reason has changed to a Codeable concept.

## typings

Ok so now...

- the builder takes a JSON object with any of the resource type
- and this is fully assisted, which is cool
- toJSON also returns the correct object, so it ejects properly
- I just need to work out how to type the builders now


I've almost got it working, although on teh declaration side I have to explicitly pass the type. It doesn't seem to want to infer it.

Next problem: in types/fhir what's with all the underscore values? They really cramp my style man



##


I am running into real troubles

Versioning is a fairly big problem, although i might be on the virtuous path

Migration though remains a big question

Scoping of the chain is another problem which I'm not sure how to deal with. That needs a rethink. And is it an untidy API?

Forget scaling - if I can't build a robust core here, I can't really justify the blog. I wanted production code alongside it.