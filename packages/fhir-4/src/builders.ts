
// THIS FILE WAS AUTO-GENERATED
// DO NOT MAKE CHANGES MANUALLY OR THEY WILL BE LOST
// SEE THE README FILE FOR DETAILS

import build_Account, { Account_Props } from "./profiles/Account";
import build_ActivityDefinition, { ActivityDefinition_Props } from "./profiles/ActivityDefinition";
import build_AdministrableProductDefinition, { AdministrableProductDefinition_Props } from "./profiles/AdministrableProductDefinition";
import build_AdverseEvent, { AdverseEvent_Props } from "./profiles/AdverseEvent";
import build_AllergyIntolerance, { AllergyIntolerance_Props } from "./profiles/AllergyIntolerance";
import build_Appointment, { Appointment_Props } from "./profiles/Appointment";
import build_AppointmentResponse, { AppointmentResponse_Props } from "./profiles/AppointmentResponse";
import build_BiologicallyDerivedProduct, { BiologicallyDerivedProduct_Props } from "./profiles/BiologicallyDerivedProduct";
import build_BodyStructure, { BodyStructure_Props } from "./profiles/BodyStructure";
import build_CarePlan, { CarePlan_Props } from "./profiles/CarePlan";
import build_CareTeam, { CareTeam_Props } from "./profiles/CareTeam";
import build_ChargeItem, { ChargeItem_Props } from "./profiles/ChargeItem";
import build_ChargeItemDefinition, { ChargeItemDefinition_Props } from "./profiles/ChargeItemDefinition";
import build_Citation, { Citation_Props } from "./profiles/Citation";
import build_Claim, { Claim_Props } from "./profiles/Claim";
import build_ClaimResponse, { ClaimResponse_Props } from "./profiles/ClaimResponse";
import build_ClinicalImpression, { ClinicalImpression_Props } from "./profiles/ClinicalImpression";
import build_ClinicalUseDefinition, { ClinicalUseDefinition_Props } from "./profiles/ClinicalUseDefinition";
import build_Communication, { Communication_Props } from "./profiles/Communication";
import build_CommunicationRequest, { CommunicationRequest_Props } from "./profiles/CommunicationRequest";
import build_Contract, { Contract_Props } from "./profiles/Contract";
import build_Coverage, { Coverage_Props } from "./profiles/Coverage";
import build_CoverageEligibilityRequest, { CoverageEligibilityRequest_Props } from "./profiles/CoverageEligibilityRequest";
import build_CoverageEligibilityResponse, { CoverageEligibilityResponse_Props } from "./profiles/CoverageEligibilityResponse";
import build_DetectedIssue, { DetectedIssue_Props } from "./profiles/DetectedIssue";
import build_Device, { Device_Props } from "./profiles/Device";
import build_DeviceDefinition, { DeviceDefinition_Props } from "./profiles/DeviceDefinition";
import build_DeviceMetric, { DeviceMetric_Props } from "./profiles/DeviceMetric";
import build_DeviceRequest, { DeviceRequest_Props } from "./profiles/DeviceRequest";
import build_DeviceUseStatement, { DeviceUseStatement_Props } from "./profiles/DeviceUseStatement";
import build_DiagnosticReport, { DiagnosticReport_Props } from "./profiles/DiagnosticReport";
import build_DomainResource, { DomainResource_Props } from "./profiles/DomainResource";
import build_Encounter, { Encounter_Props } from "./profiles/Encounter";
import build_EnrollmentRequest, { EnrollmentRequest_Props } from "./profiles/EnrollmentRequest";
import build_EnrollmentResponse, { EnrollmentResponse_Props } from "./profiles/EnrollmentResponse";
import build_EpisodeOfCare, { EpisodeOfCare_Props } from "./profiles/EpisodeOfCare";
import build_EventDefinition, { EventDefinition_Props } from "./profiles/EventDefinition";
import build_Evidence, { Evidence_Props } from "./profiles/Evidence";
import build_EvidenceReport, { EvidenceReport_Props } from "./profiles/EvidenceReport";
import build_EvidenceVariable, { EvidenceVariable_Props } from "./profiles/EvidenceVariable";
import build_ExplanationOfBenefit, { ExplanationOfBenefit_Props } from "./profiles/ExplanationOfBenefit";
import build_FamilyMemberHistory, { FamilyMemberHistory_Props } from "./profiles/FamilyMemberHistory";
import build_Flag, { Flag_Props } from "./profiles/Flag";
import build_Goal, { Goal_Props } from "./profiles/Goal";
import build_Group, { Group_Props } from "./profiles/Group";
import build_GuidanceResponse, { GuidanceResponse_Props } from "./profiles/GuidanceResponse";
import build_HealthcareService, { HealthcareService_Props } from "./profiles/HealthcareService";
import build_ImagingStudy, { ImagingStudy_Props } from "./profiles/ImagingStudy";
import build_Immunization, { Immunization_Props } from "./profiles/Immunization";
import build_ImmunizationEvaluation, { ImmunizationEvaluation_Props } from "./profiles/ImmunizationEvaluation";
import build_ImmunizationRecommendation, { ImmunizationRecommendation_Props } from "./profiles/ImmunizationRecommendation";
import build_Ingredient, { Ingredient_Props } from "./profiles/Ingredient";
import build_InsurancePlan, { InsurancePlan_Props } from "./profiles/InsurancePlan";
import build_Invoice, { Invoice_Props } from "./profiles/Invoice";
import build_Library, { Library_Props } from "./profiles/Library";
import build_List, { List_Props } from "./profiles/List";
import build_Location, { Location_Props } from "./profiles/Location";
import build_ManufacturedItemDefinition, { ManufacturedItemDefinition_Props } from "./profiles/ManufacturedItemDefinition";
import build_Measure, { Measure_Props } from "./profiles/Measure";
import build_MeasureReport, { MeasureReport_Props } from "./profiles/MeasureReport";
import build_Media, { Media_Props } from "./profiles/Media";
import build_Medication, { Medication_Props } from "./profiles/Medication";
import build_MedicationAdministration, { MedicationAdministration_Props } from "./profiles/MedicationAdministration";
import build_MedicationDispense, { MedicationDispense_Props } from "./profiles/MedicationDispense";
import build_MedicationKnowledge, { MedicationKnowledge_Props } from "./profiles/MedicationKnowledge";
import build_MedicationRequest, { MedicationRequest_Props } from "./profiles/MedicationRequest";
import build_MedicationStatement, { MedicationStatement_Props } from "./profiles/MedicationStatement";
import build_MedicinalProductDefinition, { MedicinalProductDefinition_Props } from "./profiles/MedicinalProductDefinition";
import build_MolecularSequence, { MolecularSequence_Props } from "./profiles/MolecularSequence";
import build_NutritionOrder, { NutritionOrder_Props } from "./profiles/NutritionOrder";
import build_NutritionProduct, { NutritionProduct_Props } from "./profiles/NutritionProduct";
import build_Observation, { Observation_Props } from "./profiles/Observation";
import build_ObservationDefinition, { ObservationDefinition_Props } from "./profiles/ObservationDefinition";
import build_Organization, { Organization_Props } from "./profiles/Organization";
import build_OrganizationAffiliation, { OrganizationAffiliation_Props } from "./profiles/OrganizationAffiliation";
import build_PackagedProductDefinition, { PackagedProductDefinition_Props } from "./profiles/PackagedProductDefinition";
import build_Patient, { Patient_Props } from "./profiles/Patient";
import build_PaymentNotice, { PaymentNotice_Props } from "./profiles/PaymentNotice";
import build_PaymentReconciliation, { PaymentReconciliation_Props } from "./profiles/PaymentReconciliation";
import build_Person, { Person_Props } from "./profiles/Person";
import build_PlanDefinition, { PlanDefinition_Props } from "./profiles/PlanDefinition";
import build_Practitioner, { Practitioner_Props } from "./profiles/Practitioner";
import build_PractitionerRole, { PractitionerRole_Props } from "./profiles/PractitionerRole";
import build_Procedure, { Procedure_Props } from "./profiles/Procedure";
import build_Questionnaire, { Questionnaire_Props } from "./profiles/Questionnaire";
import build_QuestionnaireResponse, { QuestionnaireResponse_Props } from "./profiles/QuestionnaireResponse";
import build_RegulatedAuthorization, { RegulatedAuthorization_Props } from "./profiles/RegulatedAuthorization";
import build_RelatedPerson, { RelatedPerson_Props } from "./profiles/RelatedPerson";
import build_RequestGroup, { RequestGroup_Props } from "./profiles/RequestGroup";
import build_ResearchDefinition, { ResearchDefinition_Props } from "./profiles/ResearchDefinition";
import build_ResearchElementDefinition, { ResearchElementDefinition_Props } from "./profiles/ResearchElementDefinition";
import build_ResearchStudy, { ResearchStudy_Props } from "./profiles/ResearchStudy";
import build_ResearchSubject, { ResearchSubject_Props } from "./profiles/ResearchSubject";
import build_RiskAssessment, { RiskAssessment_Props } from "./profiles/RiskAssessment";
import build_Schedule, { Schedule_Props } from "./profiles/Schedule";
import build_ServiceRequest, { ServiceRequest_Props } from "./profiles/ServiceRequest";
import build_Slot, { Slot_Props } from "./profiles/Slot";
import build_Specimen, { Specimen_Props } from "./profiles/Specimen";
import build_SpecimenDefinition, { SpecimenDefinition_Props } from "./profiles/SpecimenDefinition";
import build_Substance, { Substance_Props } from "./profiles/Substance";
import build_SubstanceDefinition, { SubstanceDefinition_Props } from "./profiles/SubstanceDefinition";
import build_SupplyDelivery, { SupplyDelivery_Props } from "./profiles/SupplyDelivery";
import build_SupplyRequest, { SupplyRequest_Props } from "./profiles/SupplyRequest";
import build_Task, { Task_Props } from "./profiles/Task";
import build_TestReport, { TestReport_Props } from "./profiles/TestReport";
import build_VerificationResult, { VerificationResult_Props } from "./profiles/VerificationResult";
import build_VisionPrescription, { VisionPrescription_Props } from "./profiles/VisionPrescription";
export * from "./datatypes";

/**
  * Create a Account resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {Identifier} [props.identifier] - Account number
  * @param {string} [props.status] - active | inactive | entered-in-error | on-hold | unknown
  * @param {CodeableConcept} [props.type] - E.g. patient, expense, depreciation
  * @param {string} [props.name] - Human-readable label
  * @param {Reference} [props.subject] - The entity that caused the expenses
  * @param {Period} [props.servicePeriod] - Transaction window
  * @param {BackboneElement} [props.coverage] - The party(s) that are responsible for covering the payment of this account, and what order should they be applied to the account
  * @param {Reference} [props.owner] - Entity managing the Account
  * @param {string} [props.description] - Explanation of purpose/use
  * @param {BackboneElement} [props.guarantor] - The parties ultimately responsible for balancing the Account
  * @param {Reference} [props.partOf] - Reference to a parent Account
  */
export function account(type: "Account", props: Account_Props);

export function account(props: Account_Props);

export function account(type: any, props?: any) {
    const mappings = {
        "Account": build_Account
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "Account";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a ActivityDefinition resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {string} [props.url] - Canonical identifier for this activity definition, represented as a URI (globally unique)
  * @param {Identifier} [props.identifier] - Additional identifier for the activity definition
  * @param {string} [props.version] - Business version of the activity definition
  * @param {string} [props.name] - Name for this activity definition (computer friendly)
  * @param {string} [props.title] - Name for this activity definition (human friendly)
  * @param {string} [props.subtitle] - Subordinate title of the activity definition
  * @param {string} [props.status] - draft | active | retired | unknown
  * @param {boolean} [props.experimental] - For testing purposes, not real usage
  * @param {CodeableConcept|Reference|canonical} [props.subject] - Type of individual the activity definition is intended for
  * @param {dateTime} [props.date] - Date last changed
  * @param {string} [props.publisher] - Name of the publisher (organization or individual)
  * @param {ContactDetail} [props.contact] - Contact details for the publisher
  * @param {markdown} [props.description] - Natural language description of the activity definition
  * @param {UsageContext} [props.useContext] - The context that the content is intended to support
  * @param {CodeableConcept} [props.jurisdiction] - Intended jurisdiction for activity definition (if applicable)
  * @param {markdown} [props.purpose] - Why this activity definition is defined
  * @param {string} [props.usage] - Describes the clinical usage of the activity definition
  * @param {markdown} [props.copyright] - Use and/or publishing restrictions
  * @param {date} [props.approvalDate] - When the activity definition was approved by publisher
  * @param {date} [props.lastReviewDate] - When the activity definition was last reviewed
  * @param {Period} [props.effectivePeriod] - When the activity definition is expected to be used
  * @param {CodeableConcept} [props.topic] - E.g. Education, Treatment, Assessment, etc.
  * @param {ContactDetail} [props.author] - Who authored the content
  * @param {ContactDetail} [props.editor] - Who edited the content
  * @param {ContactDetail} [props.reviewer] - Who reviewed the content
  * @param {ContactDetail} [props.endorser] - Who endorsed the content
  * @param {RelatedArtifact} [props.relatedArtifact] - Additional documentation, citations, etc.
  * @param {canonical} [props.library] - Logic used by the activity definition
  * @param {string} [props.kind] - Kind of resource
  * @param {canonical} [props.profile] - What profile the resource needs to conform to
  * @param {CodeableConcept} [props.code] - Detail type of activity
  * @param {string} [props.intent] - proposal | plan | directive | order | original-order | reflex-order | filler-order | instance-order | option
  * @param {string} [props.priority] - routine | urgent | asap | stat
  * @param {boolean} [props.doNotPerform] - True if the activity should not be performed
  * @param {Timing|dateTime|Age|Period|Range|Duration} [props.timing] - When activity is to occur
  * @param {Reference} [props.location] - Where it should happen
  * @param {BackboneElement} [props.participant] - Who should participate in the action
  * @param {Reference|CodeableConcept} [props.product] - What's administered/supplied
  * @param {Quantity} [props.quantity] - How much is administered/consumed/supplied
  * @param {Dosage} [props.dosage] - Detailed dosage instructions
  * @param {CodeableConcept} [props.bodySite] - What part of body to perform on
  * @param {Reference} [props.specimenRequirement] - What specimens are required to perform this action
  * @param {Reference} [props.observationRequirement] - What observations are required to perform this action
  * @param {Reference} [props.observationResultRequirement] - What observations must be produced by this action
  * @param {canonical} [props.transform] - Transform to apply the template
  * @param {BackboneElement} [props.dynamicValue] - Dynamic aspects of the definition
  */
export function activityDefinition(type: "ActivityDefinition", props: ActivityDefinition_Props);

export function activityDefinition(props: ActivityDefinition_Props);

export function activityDefinition(type: any, props?: any) {
    const mappings = {
        "ActivityDefinition": build_ActivityDefinition
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "ActivityDefinition";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a AdministrableProductDefinition resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {Identifier} [props.identifier] - An identifier for the administrable product
  * @param {string} [props.status] - draft | active | retired | unknown
  * @param {Reference} [props.formOf] - References a product from which one or more of the constituent parts of that product can be prepared and used as described by this administrable product
  * @param {CodeableConcept} [props.administrableDoseForm] - The dose form of the final product after necessary reconstitution or processing
  * @param {CodeableConcept} [props.unitOfPresentation] - The presentation type in which this item is given to a patient. e.g. for a spray - 'puff'
  * @param {Reference} [props.producedFrom] - Indicates the specific manufactured items that are part of the 'formOf' product that are used in the preparation of this specific administrable form
  * @param {CodeableConcept} [props.ingredient] - The ingredients of this administrable medicinal product. This is only needed if the ingredients are not specified either using ManufacturedItemDefiniton, or using by incoming references from the Ingredient resource
  * @param {Reference} [props.device] - A device that is integral to the medicinal product, in effect being considered as an "ingredient" of the medicinal product
  * @param {BackboneElement} [props.property] - Characteristics e.g. a product's onset of action
  * @param {BackboneElement} [props.routeOfAdministration] - The path by which the product is taken into or makes contact with the body
  */
export function administrableProductDefinition(
    type: "AdministrableProductDefinition",
    props: AdministrableProductDefinition_Props
);

export function administrableProductDefinition(props: AdministrableProductDefinition_Props);

export function administrableProductDefinition(type: any, props?: any) {
    const mappings = {
        "AdministrableProductDefinition": build_AdministrableProductDefinition
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "AdministrableProductDefinition";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a AdverseEvent resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {Identifier} [props.identifier] - Business identifier for the event
  * @param {string} [props.actuality] - actual | potential
  * @param {CodeableConcept} [props.category] - product-problem | product-quality | product-use-error | wrong-dose | incorrect-prescribing-information | wrong-technique | wrong-route-of-administration | wrong-rate | wrong-duration | wrong-time | expired-drug | medical-device-use-error | problem-different-manufacturer | unsafe-physical-environment
  * @param {CodeableConcept} [props.event] - Type of the event itself in relation to the subject
  * @param {Reference} [props.subject] - Subject impacted by event
  * @param {Reference} [props.encounter] - Encounter created as part of
  * @param {dateTime} [props.date] - When the event occurred
  * @param {dateTime} [props.detected] - When the event was detected
  * @param {dateTime} [props.recordedDate] - When the event was recorded
  * @param {Reference} [props.resultingCondition] - Effect on the subject due to this event
  * @param {Reference} [props.location] - Location where adverse event occurred
  * @param {CodeableConcept} [props.seriousness] - Seriousness of the event
  * @param {CodeableConcept} [props.severity] - mild | moderate | severe
  * @param {CodeableConcept} [props.outcome] - resolved | recovering | ongoing | resolvedWithSequelae | fatal | unknown
  * @param {Reference} [props.recorder] - Who recorded the adverse event
  * @param {Reference} [props.contributor] - Who  was involved in the adverse event or the potential adverse event
  * @param {BackboneElement} [props.suspectEntity] - The suspected agent causing the adverse event
  * @param {Reference} [props.subjectMedicalHistory] - AdverseEvent.subjectMedicalHistory
  * @param {Reference} [props.referenceDocument] - AdverseEvent.referenceDocument
  * @param {Reference} [props.study] - AdverseEvent.study
  */
export function adverseEvent(type: "AdverseEvent", props: AdverseEvent_Props);

export function adverseEvent(props: AdverseEvent_Props);

export function adverseEvent(type: any, props?: any) {
    const mappings = {
        "AdverseEvent": build_AdverseEvent
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "AdverseEvent";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a AllergyIntolerance resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {Identifier} [props.identifier] - External ids for this item
  * @param {CodeableConcept} [props.clinicalStatus] - active | inactive | resolved
  * @param {CodeableConcept} [props.verificationStatus] - unconfirmed | confirmed | refuted | entered-in-error
  * @param {string} [props.type] - allergy | intolerance - Underlying mechanism (if known)
  * @param {string} [props.category] - food | medication | environment | biologic
  * @param {string} [props.criticality] - low | high | unable-to-assess
  * @param {CodeableConcept} [props.code] - Code that identifies the allergy or intolerance
  * @param {Reference} [props.patient] - Who the sensitivity is for
  * @param {Reference} [props.encounter] - Encounter when the allergy or intolerance was asserted
  * @param {dateTime|Age|Period|Range|string} [props.onset] - When allergy or intolerance was identified
  * @param {dateTime} [props.recordedDate] - Date first version of the resource instance was recorded
  * @param {Reference} [props.recorder] - Who recorded the sensitivity
  * @param {Reference} [props.asserter] - Source of the information about the allergy
  * @param {dateTime} [props.lastOccurrence] - Date(/time) of last known occurrence of a reaction
  * @param {Annotation} [props.note] - Additional text not captured in other fields
  * @param {BackboneElement} [props.reaction] - Adverse Reaction Events linked to exposure to substance
  */
export function allergyIntolerance(type: "AllergyIntolerance", props: AllergyIntolerance_Props);

export function allergyIntolerance(props: AllergyIntolerance_Props);

export function allergyIntolerance(type: any, props?: any) {
    const mappings = {
        "AllergyIntolerance": build_AllergyIntolerance
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "AllergyIntolerance";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a Appointment resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {Identifier} [props.identifier] - External Ids for this item
  * @param {string} [props.status] - proposed | pending | booked | arrived | fulfilled | cancelled | noshow | entered-in-error | checked-in | waitlist
  * @param {CodeableConcept} [props.cancelationReason] - The coded reason for the appointment being cancelled
  * @param {CodeableConcept} [props.serviceCategory] - A broad categorization of the service that is to be performed during this appointment
  * @param {CodeableConcept} [props.serviceType] - The specific service that is to be performed during this appointment
  * @param {CodeableConcept} [props.specialty] - The specialty of a practitioner that would be required to perform the service requested in this appointment
  * @param {CodeableConcept} [props.appointmentType] - The style of appointment or patient that has been booked in the slot (not service type)
  * @param {CodeableConcept} [props.reasonCode] - Coded reason this appointment is scheduled
  * @param {Reference} [props.reasonReference] - Reason the appointment is to take place (resource)
  * @param {unsignedInt} [props.priority] - Used to make informed decisions if needing to re-prioritize
  * @param {string} [props.description] - Shown on a subject line in a meeting request, or appointment list
  * @param {Reference} [props.supportingInformation] - Additional information to support the appointment
  * @param {instant} [props.start] - When appointment is to take place
  * @param {instant} [props.end] - When appointment is to conclude
  * @param {number} [props.minutesDuration] - Can be less than start/end (e.g. estimate)
  * @param {Reference} [props.slot] - The slots that this appointment is filling
  * @param {dateTime} [props.created] - The date that this appointment was initially created
  * @param {string} [props.comment] - Additional comments
  * @param {string} [props.patientInstruction] - Detailed information and instructions for the patient
  * @param {Reference} [props.basedOn] - The service request this appointment is allocated to assess
  * @param {BackboneElement} [props.participant] - Participants involved in appointment
  * @param {Period} [props.requestedPeriod] - Potential date/time interval(s) requested to allocate the appointment within
  */
export function appointment(type: "Appointment", props: Appointment_Props);

export function appointment(props: Appointment_Props);

export function appointment(type: any, props?: any) {
    const mappings = {
        "Appointment": build_Appointment
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "Appointment";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a AppointmentResponse resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {Identifier} [props.identifier] - External Ids for this item
  * @param {Reference} [props.appointment] - Appointment this response relates to
  * @param {instant} [props.start] - Time from appointment, or requested new start time
  * @param {instant} [props.end] - Time from appointment, or requested new end time
  * @param {CodeableConcept} [props.participantType] - Role of participant in the appointment
  * @param {Reference} [props.actor] - Person, Location, HealthcareService, or Device
  * @param {string} [props.participantStatus] - accepted | declined | tentative | needs-action
  * @param {string} [props.comment] - Additional comments
  */
export function appointmentResponse(type: "AppointmentResponse", props: AppointmentResponse_Props);

export function appointmentResponse(props: AppointmentResponse_Props);

export function appointmentResponse(type: any, props?: any) {
    const mappings = {
        "AppointmentResponse": build_AppointmentResponse
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "AppointmentResponse";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a BiologicallyDerivedProduct resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {Identifier} [props.identifier] - External ids for this item
  * @param {string} [props.productCategory] - organ | tissue | fluid | cells | biologicalAgent
  * @param {CodeableConcept} [props.productCode] - What this biologically derived product is
  * @param {string} [props.status] - available | unavailable
  * @param {Reference} [props.request] - Procedure request
  * @param {integer} [props.quantity] - The amount of this biologically derived product
  * @param {Reference} [props.parent] - BiologicallyDerivedProduct parent
  * @param {BackboneElement} [props.collection] - How this product was collected
  * @param {BackboneElement} [props.processing] - Any processing of the product during collection
  * @param {BackboneElement} [props.manipulation] - Any manipulation of product post-collection
  * @param {BackboneElement} [props.storage] - Product storage
  */
export function biologicallyDerivedProduct(
    type: "BiologicallyDerivedProduct",
    props: BiologicallyDerivedProduct_Props
);

export function biologicallyDerivedProduct(props: BiologicallyDerivedProduct_Props);

export function biologicallyDerivedProduct(type: any, props?: any) {
    const mappings = {
        "BiologicallyDerivedProduct": build_BiologicallyDerivedProduct
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "BiologicallyDerivedProduct";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a BodyStructure resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {Identifier} [props.identifier] - Bodystructure identifier
  * @param {boolean} [props.active] - Whether this record is in active use
  * @param {CodeableConcept} [props.morphology] - Kind of Structure
  * @param {CodeableConcept} [props.location] - Body site
  * @param {CodeableConcept} [props.locationQualifier] - Body site modifier
  * @param {string} [props.description] - Text description
  * @param {Attachment} [props.image] - Attached images
  * @param {Reference} [props.patient] - Who this is about
  */
export function bodyStructure(type: "BodyStructure", props: BodyStructure_Props);

export function bodyStructure(props: BodyStructure_Props);

export function bodyStructure(type: any, props?: any) {
    const mappings = {
        "BodyStructure": build_BodyStructure
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "BodyStructure";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a CarePlan resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {Identifier} [props.identifier] - External Ids for this plan
  * @param {canonical} [props.instantiatesCanonical] - Instantiates FHIR protocol or definition
  * @param {string} [props.instantiatesUri] - Instantiates external protocol or definition
  * @param {Reference} [props.basedOn] - Fulfills CarePlan
  * @param {Reference} [props.replaces] - CarePlan replaced by this CarePlan
  * @param {Reference} [props.partOf] - Part of referenced CarePlan
  * @param {string} [props.status] - draft | active | on-hold | revoked | completed | entered-in-error | unknown
  * @param {string} [props.intent] - proposal | plan | order | option
  * @param {CodeableConcept} [props.category] - Type of plan
  * @param {string} [props.title] - Human-friendly name for the care plan
  * @param {string} [props.description] - Summary of nature of plan
  * @param {Reference} [props.subject] - Who the care plan is for
  * @param {Reference} [props.encounter] - Encounter created as part of
  * @param {Period} [props.period] - Time period plan covers
  * @param {dateTime} [props.created] - Date record was first recorded
  * @param {Reference} [props.author] - Who is the designated responsible party
  * @param {Reference} [props.contributor] - Who provided the content of the care plan
  * @param {Reference} [props.careTeam] - Who's involved in plan?
  * @param {Reference} [props.addresses] - Health issues this plan addresses
  * @param {Reference} [props.supportingInfo] - Information considered as part of plan
  * @param {Reference} [props.goal] - Desired outcome of plan
  * @param {BackboneElement} [props.activity] - Action to occur as part of plan
  * @param {Annotation} [props.note] - Comments about the plan
  */
export function carePlan(type: "CarePlan", props: CarePlan_Props);

export function carePlan(props: CarePlan_Props);

export function carePlan(type: any, props?: any) {
    const mappings = {
        "CarePlan": build_CarePlan
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "CarePlan";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a CareTeam resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {Identifier} [props.identifier] - External Ids for this team
  * @param {string} [props.status] - proposed | active | suspended | inactive | entered-in-error
  * @param {CodeableConcept} [props.category] - Type of team
  * @param {string} [props.name] - Name of the team, such as crisis assessment team
  * @param {Reference} [props.subject] - Who care team is for
  * @param {Reference} [props.encounter] - Encounter created as part of
  * @param {Period} [props.period] - Time period team covers
  * @param {BackboneElement} [props.participant] - Members of the team
  * @param {CodeableConcept} [props.reasonCode] - Why the care team exists
  * @param {Reference} [props.reasonReference] - Why the care team exists
  * @param {Reference} [props.managingOrganization] - Organization responsible for the care team
  * @param {ContactPoint} [props.telecom] - A contact detail for the care team (that applies to all members)
  * @param {Annotation} [props.note] - Comments made about the CareTeam
  */
export function careTeam(type: "CareTeam", props: CareTeam_Props);

export function careTeam(props: CareTeam_Props);

export function careTeam(type: any, props?: any) {
    const mappings = {
        "CareTeam": build_CareTeam
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "CareTeam";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a ChargeItem resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {Identifier} [props.identifier] - Business Identifier for item
  * @param {string} [props.definitionUri] - Defining information about the code of this charge item
  * @param {canonical} [props.definitionCanonical] - Resource defining the code of this ChargeItem
  * @param {string} [props.status] - planned | billable | not-billable | aborted | billed | entered-in-error | unknown
  * @param {Reference} [props.partOf] - Part of referenced ChargeItem
  * @param {CodeableConcept} [props.code] - A code that identifies the charge, like a billing code
  * @param {Reference} [props.subject] - Individual service was done for/to
  * @param {Reference} [props.context] - Encounter / Episode associated with event
  * @param {dateTime|Period|Timing} [props.occurrence] - When the charged service was applied
  * @param {BackboneElement} [props.performer] - Who performed charged service
  * @param {Reference} [props.performingOrganization] - Organization providing the charged service
  * @param {Reference} [props.requestingOrganization] - Organization requesting the charged service
  * @param {Reference} [props.costCenter] - Organization that has ownership of the (potential, future) revenue
  * @param {Quantity} [props.quantity] - Quantity of which the charge item has been serviced
  * @param {CodeableConcept} [props.bodysite] - Anatomical location, if relevant
  * @param {decimal} [props.factorOverride] - Factor overriding the associated rules
  * @param {Money} [props.priceOverride] - Price overriding the associated rules
  * @param {string} [props.overrideReason] - Reason for overriding the list price/factor
  * @param {Reference} [props.enterer] - Individual who was entering
  * @param {dateTime} [props.enteredDate] - Date the charge item was entered
  * @param {CodeableConcept} [props.reason] - Why was the charged  service rendered?
  * @param {Reference} [props.service] - Which rendered service is being charged?
  * @param {Reference|CodeableConcept} [props.product] - Product charged
  * @param {Reference} [props.account] - Account to place this charge
  * @param {Annotation} [props.note] - Comments made about the ChargeItem
  * @param {Reference} [props.supportingInformation] - Further information supporting this charge
  */
export function chargeItem(type: "ChargeItem", props: ChargeItem_Props);

export function chargeItem(props: ChargeItem_Props);

export function chargeItem(type: any, props?: any) {
    const mappings = {
        "ChargeItem": build_ChargeItem
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "ChargeItem";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a ChargeItemDefinition resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {string} [props.url] - Canonical identifier for this charge item definition, represented as a URI (globally unique)
  * @param {Identifier} [props.identifier] - Additional identifier for the charge item definition
  * @param {string} [props.version] - Business version of the charge item definition
  * @param {string} [props.title] - Name for this charge item definition (human friendly)
  * @param {string} [props.derivedFromUri] - Underlying externally-defined charge item definition
  * @param {canonical} [props.partOf] - A larger definition of which this particular definition is a component or step
  * @param {canonical} [props.replaces] - Completed or terminated request(s) whose function is taken by this new request
  * @param {string} [props.status] - draft | active | retired | unknown
  * @param {boolean} [props.experimental] - For testing purposes, not real usage
  * @param {dateTime} [props.date] - Date last changed
  * @param {string} [props.publisher] - Name of the publisher (organization or individual)
  * @param {ContactDetail} [props.contact] - Contact details for the publisher
  * @param {markdown} [props.description] - Natural language description of the charge item definition
  * @param {UsageContext} [props.useContext] - The context that the content is intended to support
  * @param {CodeableConcept} [props.jurisdiction] - Intended jurisdiction for charge item definition (if applicable)
  * @param {markdown} [props.copyright] - Use and/or publishing restrictions
  * @param {date} [props.approvalDate] - When the charge item definition was approved by publisher
  * @param {date} [props.lastReviewDate] - When the charge item definition was last reviewed
  * @param {Period} [props.effectivePeriod] - When the charge item definition is expected to be used
  * @param {CodeableConcept} [props.code] - Billing codes or product types this definition applies to
  * @param {Reference} [props.instance] - Instances this definition applies to
  * @param {BackboneElement} [props.applicability] - Whether or not the billing code is applicable
  * @param {BackboneElement} [props.propertyGroup] - Group of properties which are applicable under the same conditions
  */
export function chargeItemDefinition(type: "ChargeItemDefinition", props: ChargeItemDefinition_Props);

export function chargeItemDefinition(props: ChargeItemDefinition_Props);

export function chargeItemDefinition(type: any, props?: any) {
    const mappings = {
        "ChargeItemDefinition": build_ChargeItemDefinition
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "ChargeItemDefinition";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a Citation resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {string} [props.url] - Canonical identifier for this citation, represented as a globally unique URI
  * @param {Identifier} [props.identifier] - Identifier for the Citation resource itself
  * @param {string} [props.version] - Business version of the citation
  * @param {string} [props.name] - Name for this citation (computer friendly)
  * @param {string} [props.title] - Name for this citation (human friendly)
  * @param {string} [props.status] - draft | active | retired | unknown
  * @param {boolean} [props.experimental] - For testing purposes, not real usage
  * @param {dateTime} [props.date] - Date last changed
  * @param {string} [props.publisher] - The publisher of the Citation, not the publisher of the article or artifact being cited
  * @param {ContactDetail} [props.contact] - Contact details for the publisher of the Citation Resource
  * @param {markdown} [props.description] - Natural language description of the citation
  * @param {UsageContext} [props.useContext] - The context that the Citation Resource content is intended to support
  * @param {CodeableConcept} [props.jurisdiction] - Intended jurisdiction for citation (if applicable)
  * @param {markdown} [props.purpose] - Why this citation is defined
  * @param {markdown} [props.copyright] - Use and/or publishing restrictions for the Citation, not for the cited artifact
  * @param {date} [props.approvalDate] - When the citation was approved by publisher
  * @param {date} [props.lastReviewDate] - When the citation was last reviewed
  * @param {Period} [props.effectivePeriod] - When the citation is expected to be used
  * @param {ContactDetail} [props.author] - Who authored the Citation
  * @param {ContactDetail} [props.editor] - Who edited the Citation
  * @param {ContactDetail} [props.reviewer] - Who reviewed the Citation
  * @param {ContactDetail} [props.endorser] - Who endorsed the Citation
  * @param {BackboneElement} [props.summary] - A human-readable display of the citation
  * @param {BackboneElement} [props.classification] - The assignment to an organizing scheme
  * @param {Annotation} [props.note] - Used for general notes and annotations not coded elsewhere
  * @param {CodeableConcept} [props.currentState] - The status of the citation
  * @param {BackboneElement} [props.statusDate] - An effective date or period for a status of the citation
  * @param {BackboneElement} [props.relatesTo] - Artifact related to the Citation Resource
  * @param {BackboneElement} [props.citedArtifact] - The article or artifact being described
  */
export function citation(type: "Citation", props: Citation_Props);

export function citation(props: Citation_Props);

export function citation(type: any, props?: any) {
    const mappings = {
        "Citation": build_Citation
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "Citation";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a Claim resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {Identifier} [props.identifier] - Business Identifier for claim
  * @param {string} [props.status] - active | cancelled | draft | entered-in-error
  * @param {CodeableConcept} [props.type] - Category or discipline
  * @param {CodeableConcept} [props.subType] - More granular claim type
  * @param {string} [props.use] - claim | preauthorization | predetermination
  * @param {Reference} [props.patient] - The recipient of the products and services
  * @param {Period} [props.billablePeriod] - Relevant time frame for the claim
  * @param {dateTime} [props.created] - Resource creation date
  * @param {Reference} [props.enterer] - Author of the claim
  * @param {Reference} [props.insurer] - Target
  * @param {Reference} [props.provider] - Party responsible for the claim
  * @param {CodeableConcept} [props.priority] - Desired processing ugency
  * @param {CodeableConcept} [props.fundsReserve] - For whom to reserve funds
  * @param {BackboneElement} [props.related] - Prior or corollary claims
  * @param {Reference} [props.prescription] - Prescription authorizing services and products
  * @param {Reference} [props.originalPrescription] - Original prescription if superseded by fulfiller
  * @param {BackboneElement} [props.payee] - Recipient of benefits payable
  * @param {Reference} [props.referral] - Treatment referral
  * @param {Reference} [props.facility] - Servicing facility
  * @param {BackboneElement} [props.careTeam] - Members of the care team
  * @param {BackboneElement} [props.supportingInfo] - Supporting information
  * @param {BackboneElement} [props.diagnosis] - Pertinent diagnosis information
  * @param {BackboneElement} [props.procedure] - Clinical procedures performed
  * @param {BackboneElement} [props.insurance] - Patient insurance information
  * @param {BackboneElement} [props.accident] - Details of the event
  * @param {BackboneElement} [props.item] - Product or service provided
  * @param {Money} [props.total] - Total claim cost
  */
export function claim(type: "Claim", props: Claim_Props);

export function claim(props: Claim_Props);

export function claim(type: any, props?: any) {
    const mappings = {
        "Claim": build_Claim
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "Claim";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a ClaimResponse resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {Identifier} [props.identifier] - Business Identifier for a claim response
  * @param {string} [props.status] - active | cancelled | draft | entered-in-error
  * @param {CodeableConcept} [props.type] - More granular claim type
  * @param {CodeableConcept} [props.subType] - More granular claim type
  * @param {string} [props.use] - claim | preauthorization | predetermination
  * @param {Reference} [props.patient] - The recipient of the products and services
  * @param {dateTime} [props.created] - Response creation date
  * @param {Reference} [props.insurer] - Party responsible for reimbursement
  * @param {Reference} [props.requestor] - Party responsible for the claim
  * @param {Reference} [props.request] - Id of resource triggering adjudication
  * @param {string} [props.outcome] - queued | complete | error | partial
  * @param {string} [props.disposition] - Disposition Message
  * @param {string} [props.preAuthRef] - Preauthorization reference
  * @param {Period} [props.preAuthPeriod] - Preauthorization reference effective period
  * @param {CodeableConcept} [props.payeeType] - Party to be paid any benefits payable
  * @param {BackboneElement} [props.item] - Adjudication for claim line items
  * @param {BackboneElement} [props.addItem] - Insurer added line items
  * @param {any} [props.adjudication] - Header-level adjudication
  * @param {BackboneElement} [props.total] - Adjudication totals
  * @param {BackboneElement} [props.payment] - Payment Details
  * @param {CodeableConcept} [props.fundsReserve] - Funds reserved status
  * @param {CodeableConcept} [props.formCode] - Printed form identifier
  * @param {Attachment} [props.form] - Printed reference or actual form
  * @param {BackboneElement} [props.processNote] - Note concerning adjudication
  * @param {Reference} [props.communicationRequest] - Request for additional information
  * @param {BackboneElement} [props.insurance] - Patient insurance information
  * @param {BackboneElement} [props.error] - Processing errors
  */
export function claimResponse(type: "ClaimResponse", props: ClaimResponse_Props);

export function claimResponse(props: ClaimResponse_Props);

export function claimResponse(type: any, props?: any) {
    const mappings = {
        "ClaimResponse": build_ClaimResponse
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "ClaimResponse";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a ClinicalImpression resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {Identifier} [props.identifier] - Business identifier
  * @param {string} [props.status] - in-progress | completed | entered-in-error
  * @param {CodeableConcept} [props.statusReason] - Reason for current status
  * @param {CodeableConcept} [props.code] - Kind of assessment performed
  * @param {string} [props.description] - Why/how the assessment was performed
  * @param {Reference} [props.subject] - Patient or group assessed
  * @param {Reference} [props.encounter] - Encounter created as part of
  * @param {dateTime|Period} [props.effective] - Time of assessment
  * @param {dateTime} [props.date] - When the assessment was documented
  * @param {Reference} [props.assessor] - The clinician performing the assessment
  * @param {Reference} [props.previous] - Reference to last assessment
  * @param {Reference} [props.problem] - Relevant impressions of patient state
  * @param {BackboneElement} [props.investigation] - One or more sets of investigations (signs, symptoms, etc.)
  * @param {string} [props.protocol] - Clinical Protocol followed
  * @param {string} [props.summary] - Summary of the assessment
  * @param {BackboneElement} [props.finding] - Possible or likely findings and diagnoses
  * @param {CodeableConcept} [props.prognosisCodeableConcept] - Estimate of likely outcome
  * @param {Reference} [props.prognosisReference] - RiskAssessment expressing likely outcome
  * @param {Reference} [props.supportingInfo] - Information supporting the clinical impression
  * @param {Annotation} [props.note] - Comments made about the ClinicalImpression
  */
export function clinicalImpression(type: "ClinicalImpression", props: ClinicalImpression_Props);

export function clinicalImpression(props: ClinicalImpression_Props);

export function clinicalImpression(type: any, props?: any) {
    const mappings = {
        "ClinicalImpression": build_ClinicalImpression
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "ClinicalImpression";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a ClinicalUseDefinition resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {Identifier} [props.identifier] - Business identifier for this issue
  * @param {string} [props.type] - indication | contraindication | interaction | undesirable-effect | warning
  * @param {CodeableConcept} [props.category] - A categorisation of the issue, primarily for dividing warnings into subject heading areas such as "Pregnancy", "Overdose"
  * @param {Reference} [props.subject] - The medication or procedure for which this is an indication
  * @param {CodeableConcept} [props.status] - Whether this is a current issue or one that has been retired etc
  * @param {BackboneElement} [props.contraindication] - Specifics for when this is a contraindication
  * @param {BackboneElement} [props.indication] - Specifics for when this is an indication
  * @param {BackboneElement} [props.interaction] - Specifics for when this is an interaction
  * @param {Reference} [props.population] - The population group to which this applies
  * @param {BackboneElement} [props.undesirableEffect] - A possible negative outcome from the use of this treatment
  * @param {BackboneElement} [props.warning] - Critical environmental, health or physical risks or hazards. For example 'Do not operate heavy machinery', 'May cause drowsiness'
  */
export function clinicalUseDefinition(type: "ClinicalUseDefinition", props: ClinicalUseDefinition_Props);

export function clinicalUseDefinition(props: ClinicalUseDefinition_Props);

export function clinicalUseDefinition(type: any, props?: any) {
    const mappings = {
        "ClinicalUseDefinition": build_ClinicalUseDefinition
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "ClinicalUseDefinition";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a Communication resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {Identifier} [props.identifier] - Unique identifier
  * @param {canonical} [props.instantiatesCanonical] - Instantiates FHIR protocol or definition
  * @param {string} [props.instantiatesUri] - Instantiates external protocol or definition
  * @param {Reference} [props.basedOn] - Request fulfilled by this communication
  * @param {Reference} [props.partOf] - Part of this action
  * @param {Reference} [props.inResponseTo] - Reply to
  * @param {string} [props.status] - preparation | in-progress | not-done | on-hold | stopped | completed | entered-in-error | unknown
  * @param {CodeableConcept} [props.statusReason] - Reason for current status
  * @param {CodeableConcept} [props.category] - Message category
  * @param {string} [props.priority] - routine | urgent | asap | stat
  * @param {CodeableConcept} [props.medium] - A channel of communication
  * @param {Reference} [props.subject] - Focus of message
  * @param {CodeableConcept} [props.topic] - Description of the purpose/content
  * @param {Reference} [props.about] - Resources that pertain to this communication
  * @param {Reference} [props.encounter] - Encounter created as part of
  * @param {dateTime} [props.sent] - When sent
  * @param {dateTime} [props.received] - When received
  * @param {Reference} [props.recipient] - Message recipient
  * @param {Reference} [props.sender] - Message sender
  * @param {CodeableConcept} [props.reasonCode] - Indication for message
  * @param {Reference} [props.reasonReference] - Why was communication done?
  * @param {BackboneElement} [props.payload] - Message payload
  * @param {Annotation} [props.note] - Comments made about the communication
  */
export function communication(type: "Communication", props: Communication_Props);

export function communication(props: Communication_Props);

export function communication(type: any, props?: any) {
    const mappings = {
        "Communication": build_Communication
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "Communication";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a CommunicationRequest resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {Identifier} [props.identifier] - Unique identifier
  * @param {Reference} [props.basedOn] - Fulfills plan or proposal
  * @param {Reference} [props.replaces] - Request(s) replaced by this request
  * @param {Identifier} [props.groupIdentifier] - Composite request this is part of
  * @param {string} [props.status] - draft | active | on-hold | revoked | completed | entered-in-error | unknown
  * @param {CodeableConcept} [props.statusReason] - Reason for current status
  * @param {CodeableConcept} [props.category] - Message category
  * @param {string} [props.priority] - routine | urgent | asap | stat
  * @param {boolean} [props.doNotPerform] - True if request is prohibiting action
  * @param {CodeableConcept} [props.medium] - A channel of communication
  * @param {Reference} [props.subject] - Focus of message
  * @param {Reference} [props.about] - Resources that pertain to this communication request
  * @param {Reference} [props.encounter] - Encounter created as part of
  * @param {BackboneElement} [props.payload] - Message payload
  * @param {dateTime|Period} [props.occurrence] - When scheduled
  * @param {dateTime} [props.authoredOn] - When request transitioned to being actionable
  * @param {Reference} [props.requester] - Who/what is requesting service
  * @param {Reference} [props.recipient] - Message recipient
  * @param {Reference} [props.sender] - Message sender
  * @param {CodeableConcept} [props.reasonCode] - Why is communication needed?
  * @param {Reference} [props.reasonReference] - Why is communication needed?
  * @param {Annotation} [props.note] - Comments made about communication request
  */
export function communicationRequest(type: "CommunicationRequest", props: CommunicationRequest_Props);

export function communicationRequest(props: CommunicationRequest_Props);

export function communicationRequest(type: any, props?: any) {
    const mappings = {
        "CommunicationRequest": build_CommunicationRequest
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "CommunicationRequest";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a Contract resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {Identifier} [props.identifier] - Contract number
  * @param {string} [props.url] - Basal definition
  * @param {string} [props.version] - Business edition
  * @param {string} [props.status] - amended | appended | cancelled | disputed | entered-in-error | executable | executed | negotiable | offered | policy | rejected | renewed | revoked | resolved | terminated
  * @param {CodeableConcept} [props.legalState] - Negotiation status
  * @param {Reference} [props.instantiatesCanonical] - Source Contract Definition
  * @param {string} [props.instantiatesUri] - External Contract Definition
  * @param {CodeableConcept} [props.contentDerivative] - Content derived from the basal information
  * @param {dateTime} [props.issued] - When this Contract was issued
  * @param {Period} [props.applies] - Effective time
  * @param {CodeableConcept} [props.expirationType] - Contract cessation cause
  * @param {Reference} [props.subject] - Contract Target Entity
  * @param {Reference} [props.authority] - Authority under which this Contract has standing
  * @param {Reference} [props.domain] - A sphere of control governed by an authoritative jurisdiction, organization, or person
  * @param {Reference} [props.site] - Specific Location
  * @param {string} [props.name] - Computer friendly designation
  * @param {string} [props.title] - Human Friendly name
  * @param {string} [props.subtitle] - Subordinate Friendly name
  * @param {string} [props.alias] - Acronym or short name
  * @param {Reference} [props.author] - Source of Contract
  * @param {CodeableConcept} [props.scope] - Range of Legal Concerns
  * @param {CodeableConcept|Reference} [props.topic] - Focus of contract interest
  * @param {CodeableConcept} [props.type] - Legal instrument category
  * @param {CodeableConcept} [props.subType] - Subtype within the context of type
  * @param {BackboneElement} [props.contentDefinition] - Contract precursor content
  * @param {BackboneElement} [props.term] - Contract Term List
  * @param {Reference} [props.supportingInfo] - Extra Information
  * @param {Reference} [props.relevantHistory] - Key event in Contract History
  * @param {BackboneElement} [props.signer] - Contract Signatory
  * @param {BackboneElement} [props.friendly] - Contract Friendly Language
  * @param {BackboneElement} [props.legal] - Contract Legal Language
  * @param {BackboneElement} [props.rule] - Computable Contract Language
  * @param {Attachment|Reference} [props.legallyBinding] - Binding Contract
  */
export function contract(type: "Contract", props: Contract_Props);

export function contract(props: Contract_Props);

export function contract(type: any, props?: any) {
    const mappings = {
        "Contract": build_Contract
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "Contract";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a Coverage resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {Identifier} [props.identifier] - Business Identifier for the coverage
  * @param {string} [props.status] - active | cancelled | draft | entered-in-error
  * @param {CodeableConcept} [props.type] - Coverage category such as medical or accident
  * @param {Reference} [props.policyHolder] - Owner of the policy
  * @param {Reference} [props.subscriber] - Subscriber to the policy
  * @param {string} [props.subscriberId] - ID assigned to the subscriber
  * @param {Reference} [props.beneficiary] - Plan beneficiary
  * @param {string} [props.dependent] - Dependent number
  * @param {CodeableConcept} [props.relationship] - Beneficiary relationship to the subscriber
  * @param {Period} [props.period] - Coverage start and end dates
  * @param {Reference} [props.payor] - Issuer of the policy
  * @param {BackboneElement} [props.class] - Additional coverage classifications
  * @param {number} [props.order] - Relative order of the coverage
  * @param {string} [props.network] - Insurer network
  * @param {BackboneElement} [props.costToBeneficiary] - Patient payments for services/products
  * @param {boolean} [props.subrogation] - Reimbursement to insurer
  * @param {Reference} [props.contract] - Contract details
  */
export function coverage(type: "Coverage", props: Coverage_Props);

export function coverage(props: Coverage_Props);

export function coverage(type: any, props?: any) {
    const mappings = {
        "Coverage": build_Coverage
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "Coverage";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a CoverageEligibilityRequest resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {Identifier} [props.identifier] - Business Identifier for coverage eligiblity request
  * @param {string} [props.status] - active | cancelled | draft | entered-in-error
  * @param {CodeableConcept} [props.priority] - Desired processing priority
  * @param {string} [props.purpose] - auth-requirements | benefits | discovery | validation
  * @param {Reference} [props.patient] - Intended recipient of products and services
  * @param {date|Period} [props.serviced] - Estimated date or dates of service
  * @param {dateTime} [props.created] - Creation date
  * @param {Reference} [props.enterer] - Author
  * @param {Reference} [props.provider] - Party responsible for the request
  * @param {Reference} [props.insurer] - Coverage issuer
  * @param {Reference} [props.facility] - Servicing facility
  * @param {BackboneElement} [props.supportingInfo] - Supporting information
  * @param {BackboneElement} [props.insurance] - Patient insurance information
  * @param {BackboneElement} [props.item] - Item to be evaluated for eligibiity
  */
export function coverageEligibilityRequest(
    type: "CoverageEligibilityRequest",
    props: CoverageEligibilityRequest_Props
);

export function coverageEligibilityRequest(props: CoverageEligibilityRequest_Props);

export function coverageEligibilityRequest(type: any, props?: any) {
    const mappings = {
        "CoverageEligibilityRequest": build_CoverageEligibilityRequest
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "CoverageEligibilityRequest";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a CoverageEligibilityResponse resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {Identifier} [props.identifier] - Business Identifier for coverage eligiblity request
  * @param {string} [props.status] - active | cancelled | draft | entered-in-error
  * @param {string} [props.purpose] - auth-requirements | benefits | discovery | validation
  * @param {Reference} [props.patient] - Intended recipient of products and services
  * @param {date|Period} [props.serviced] - Estimated date or dates of service
  * @param {dateTime} [props.created] - Response creation date
  * @param {Reference} [props.requestor] - Party responsible for the request
  * @param {Reference} [props.request] - Eligibility request reference
  * @param {string} [props.outcome] - queued | complete | error | partial
  * @param {string} [props.disposition] - Disposition Message
  * @param {Reference} [props.insurer] - Coverage issuer
  * @param {BackboneElement} [props.insurance] - Patient insurance information
  * @param {string} [props.preAuthRef] - Preauthorization reference
  * @param {CodeableConcept} [props.form] - Printed form identifier
  * @param {BackboneElement} [props.error] - Processing errors
  */
export function coverageEligibilityResponse(
    type: "CoverageEligibilityResponse",
    props: CoverageEligibilityResponse_Props
);

export function coverageEligibilityResponse(props: CoverageEligibilityResponse_Props);

export function coverageEligibilityResponse(type: any, props?: any) {
    const mappings = {
        "CoverageEligibilityResponse": build_CoverageEligibilityResponse
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "CoverageEligibilityResponse";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a DetectedIssue resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {Identifier} [props.identifier] - Unique id for the detected issue
  * @param {string} [props.status] - registered | preliminary | final | amended +
  * @param {CodeableConcept} [props.code] - Issue Category, e.g. drug-drug, duplicate therapy, etc.
  * @param {string} [props.severity] - high | moderate | low
  * @param {Reference} [props.patient] - Associated patient
  * @param {dateTime|Period} [props.identified] - When identified
  * @param {Reference} [props.author] - The provider or device that identified the issue
  * @param {Reference} [props.implicated] - Problem resource
  * @param {BackboneElement} [props.evidence] - Supporting evidence
  * @param {string} [props.detail] - Description and context
  * @param {string} [props.reference] - Authority for issue
  * @param {BackboneElement} [props.mitigation] - Step taken to address
  */
export function detectedIssue(type: "DetectedIssue", props: DetectedIssue_Props);

export function detectedIssue(props: DetectedIssue_Props);

export function detectedIssue(type: any, props?: any) {
    const mappings = {
        "DetectedIssue": build_DetectedIssue
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "DetectedIssue";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a Device resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {Identifier} [props.identifier] - Instance identifier
  * @param {Reference} [props.definition] - The reference to the definition for the device
  * @param {BackboneElement} [props.udiCarrier] - Unique Device Identifier (UDI) Barcode string
  * @param {string} [props.status] - active | inactive | entered-in-error | unknown
  * @param {CodeableConcept} [props.statusReason] - online | paused | standby | offline | not-ready | transduc-discon | hw-discon | off
  * @param {string} [props.distinctIdentifier] - The distinct identification string
  * @param {string} [props.manufacturer] - Name of device manufacturer
  * @param {dateTime} [props.manufactureDate] - Date when the device was made
  * @param {dateTime} [props.expirationDate] - Date and time of expiry of this device (if applicable)
  * @param {string} [props.lotNumber] - Lot number of manufacture
  * @param {string} [props.serialNumber] - Serial number assigned by the manufacturer
  * @param {BackboneElement} [props.deviceName] - The name of the device as given by the manufacturer
  * @param {string} [props.modelNumber] - The manufacturer's model number for the device
  * @param {string} [props.partNumber] - The part number or catalog number of the device
  * @param {CodeableConcept} [props.type] - The kind or type of device
  * @param {BackboneElement} [props.specialization] - The capabilities supported on a  device, the standards to which the device conforms for a particular purpose, and used for the communication
  * @param {BackboneElement} [props.version] - The actual design of the device or software version running on the device
  * @param {BackboneElement} [props.property] - The actual configuration settings of a device as it actually operates, e.g., regulation status, time properties
  * @param {Reference} [props.patient] - Patient to whom Device is affixed
  * @param {Reference} [props.owner] - Organization responsible for device
  * @param {ContactPoint} [props.contact] - Details for human/organization for support
  * @param {Reference} [props.location] - Where the device is found
  * @param {string} [props.url] - Network address to contact device
  * @param {Annotation} [props.note] - Device notes and comments
  * @param {CodeableConcept} [props.safety] - Safety Characteristics of Device
  * @param {Reference} [props.parent] - The device that this device is attached to or is part of
  */
export function device(type: "Device", props: Device_Props);

export function device(props: Device_Props);

export function device(type: any, props?: any) {
    const mappings = {
        "Device": build_Device
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "Device";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a DeviceDefinition resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {Identifier} [props.identifier] - Instance identifier
  * @param {BackboneElement} [props.udiDeviceIdentifier] - Unique Device Identifier (UDI) Barcode string
  * @param {string|Reference} [props.manufacturer] - Name of device manufacturer
  * @param {BackboneElement} [props.deviceName] - A name given to the device to identify it
  * @param {string} [props.modelNumber] - The model number for the device
  * @param {CodeableConcept} [props.type] - What kind of device or device system this is
  * @param {BackboneElement} [props.specialization] - The capabilities supported on a  device, the standards to which the device conforms for a particular purpose, and used for the communication
  * @param {string} [props.version] - Available versions
  * @param {CodeableConcept} [props.safety] - Safety characteristics of the device
  * @param {ProductShelfLife} [props.shelfLifeStorage] - Shelf Life and storage information
  * @param {ProdCharacteristic} [props.physicalCharacteristics] - Dimensions, color etc.
  * @param {CodeableConcept} [props.languageCode] - Language code for the human-readable text strings produced by the device (all supported)
  * @param {BackboneElement} [props.capability] - Device capabilities
  * @param {BackboneElement} [props.property] - The actual configuration settings of a device as it actually operates, e.g., regulation status, time properties
  * @param {Reference} [props.owner] - Organization responsible for device
  * @param {ContactPoint} [props.contact] - Details for human/organization for support
  * @param {string} [props.url] - Network address to contact device
  * @param {string} [props.onlineInformation] - Access to on-line information
  * @param {Annotation} [props.note] - Device notes and comments
  * @param {Quantity} [props.quantity] - The quantity of the device present in the packaging (e.g. the number of devices present in a pack, or the number of devices in the same package of the medicinal product)
  * @param {Reference} [props.parentDevice] - The parent device it can be part of
  * @param {BackboneElement} [props.material] - A substance used to create the material(s) of which the device is made
  */
export function deviceDefinition(type: "DeviceDefinition", props: DeviceDefinition_Props);

export function deviceDefinition(props: DeviceDefinition_Props);

export function deviceDefinition(type: any, props?: any) {
    const mappings = {
        "DeviceDefinition": build_DeviceDefinition
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "DeviceDefinition";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a DeviceMetric resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {Identifier} [props.identifier] - Instance identifier
  * @param {CodeableConcept} [props.type] - Identity of metric, for example Heart Rate or PEEP Setting
  * @param {CodeableConcept} [props.unit] - Unit of Measure for the Metric
  * @param {Reference} [props.source] - Describes the link to the source Device
  * @param {Reference} [props.parent] - Describes the link to the parent Device
  * @param {string} [props.operationalStatus] - on | off | standby | entered-in-error
  * @param {string} [props.color] - black | red | green | yellow | blue | magenta | cyan | white
  * @param {string} [props.category] - measurement | setting | calculation | unspecified
  * @param {Timing} [props.measurementPeriod] - Describes the measurement repetition time
  * @param {BackboneElement} [props.calibration] - Describes the calibrations that have been performed or that are required to be performed
  */
export function deviceMetric(type: "DeviceMetric", props: DeviceMetric_Props);

export function deviceMetric(props: DeviceMetric_Props);

export function deviceMetric(type: any, props?: any) {
    const mappings = {
        "DeviceMetric": build_DeviceMetric
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "DeviceMetric";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a DeviceRequest resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {Identifier} [props.identifier] - External Request identifier
  * @param {canonical} [props.instantiatesCanonical] - Instantiates FHIR protocol or definition
  * @param {string} [props.instantiatesUri] - Instantiates external protocol or definition
  * @param {Reference} [props.basedOn] - What request fulfills
  * @param {Reference} [props.priorRequest] - What request replaces
  * @param {Identifier} [props.groupIdentifier] - Identifier of composite request
  * @param {string} [props.status] - draft | active | on-hold | revoked | completed | entered-in-error | unknown
  * @param {string} [props.intent] - proposal | plan | directive | order | original-order | reflex-order | filler-order | instance-order | option
  * @param {string} [props.priority] - routine | urgent | asap | stat
  * @param {Reference|CodeableConcept} [props.code] - Device requested
  * @param {BackboneElement} [props.parameter] - Device details
  * @param {Reference} [props.subject] - Focus of request
  * @param {Reference} [props.encounter] - Encounter motivating request
  * @param {dateTime|Period|Timing} [props.occurrence] - Desired time or schedule for use
  * @param {dateTime} [props.authoredOn] - When recorded
  * @param {Reference} [props.requester] - Who/what is requesting diagnostics
  * @param {CodeableConcept} [props.performerType] - Filler role
  * @param {Reference} [props.performer] - Requested Filler
  * @param {CodeableConcept} [props.reasonCode] - Coded Reason for request
  * @param {Reference} [props.reasonReference] - Linked Reason for request
  * @param {Reference} [props.insurance] - Associated insurance coverage
  * @param {Reference} [props.supportingInfo] - Additional clinical information
  * @param {Annotation} [props.note] - Notes or comments
  * @param {Reference} [props.relevantHistory] - Request provenance
  */
export function deviceRequest(type: "DeviceRequest", props: DeviceRequest_Props);

export function deviceRequest(props: DeviceRequest_Props);

export function deviceRequest(type: any, props?: any) {
    const mappings = {
        "DeviceRequest": build_DeviceRequest
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "DeviceRequest";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a DeviceUseStatement resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {Identifier} [props.identifier] - External identifier for this record
  * @param {Reference} [props.basedOn] - Fulfills plan, proposal or order
  * @param {string} [props.status] - active | completed | entered-in-error +
  * @param {Reference} [props.subject] - Patient using device
  * @param {Reference} [props.derivedFrom] - Supporting information
  * @param {Timing|Period|dateTime} [props.timing] - How often  the device was used
  * @param {dateTime} [props.recordedOn] - When statement was recorded
  * @param {Reference} [props.source] - Who made the statement
  * @param {Reference} [props.device] - Reference to device used
  * @param {CodeableConcept} [props.reasonCode] - Why device was used
  * @param {Reference} [props.reasonReference] - Why was DeviceUseStatement performed?
  * @param {CodeableConcept} [props.bodySite] - Target body site
  * @param {Annotation} [props.note] - Addition details (comments, instructions)
  */
export function deviceUseStatement(type: "DeviceUseStatement", props: DeviceUseStatement_Props);

export function deviceUseStatement(props: DeviceUseStatement_Props);

export function deviceUseStatement(type: any, props?: any) {
    const mappings = {
        "DeviceUseStatement": build_DeviceUseStatement
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "DeviceUseStatement";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a DiagnosticReport resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {Identifier} [props.identifier] - Business identifier for report
  * @param {Reference} [props.basedOn] - What was requested
  * @param {string} [props.status] - registered | partial | preliminary | final +
  * @param {CodeableConcept} [props.category] - Service category
  * @param {CodeableConcept} [props.code] - Name/Code for this diagnostic report
  * @param {Reference} [props.subject] - The subject of the report - usually, but not always, the patient
  * @param {Reference} [props.encounter] - Health care event when test ordered
  * @param {dateTime|Period} [props.effective] - Clinically relevant time/time-period for report
  * @param {instant} [props.issued] - DateTime this version was made
  * @param {Reference} [props.performer] - Responsible Diagnostic Service
  * @param {Reference} [props.resultsInterpreter] - Primary result interpreter
  * @param {Reference} [props.specimen] - Specimens this report is based on
  * @param {Reference} [props.result] - Observations
  * @param {Reference} [props.imagingStudy] - Reference to full details of imaging associated with the diagnostic report
  * @param {BackboneElement} [props.media] - Key images associated with this report
  * @param {string} [props.conclusion] - Clinical conclusion (interpretation) of test results
  * @param {CodeableConcept} [props.conclusionCode] - Codes for the clinical conclusion of test results
  * @param {Attachment} [props.presentedForm] - Entire report as issued
  */
export function diagnosticReport(type: "DiagnosticReport", props: DiagnosticReport_Props);

export function diagnosticReport(props: DiagnosticReport_Props);

export function diagnosticReport(type: any, props?: any) {
    const mappings = {
        "DiagnosticReport": build_DiagnosticReport
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "DiagnosticReport";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a DomainResource resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).

  */
export function domainResource(type: "DomainResource", props: DomainResource_Props);

export function domainResource(props: DomainResource_Props);

export function domainResource(type: any, props?: any) {
    const mappings = {
        "DomainResource": build_DomainResource
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "DomainResource";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a Encounter resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {Identifier} [props.identifier] - Identifier(s) by which this encounter is known
  * @param {string} [props.status] - planned | arrived | triaged | in-progress | onleave | finished | cancelled +
  * @param {BackboneElement} [props.statusHistory] - List of past encounter statuses
  * @param {Coding} [props.class] - Classification of patient encounter
  * @param {BackboneElement} [props.classHistory] - List of past encounter classes
  * @param {CodeableConcept} [props.type] - Specific type of encounter
  * @param {CodeableConcept} [props.serviceType] - Specific type of service
  * @param {CodeableConcept} [props.priority] - Indicates the urgency of the encounter
  * @param {Reference} [props.subject] - The patient or group present at the encounter
  * @param {Reference} [props.episodeOfCare] - Episode(s) of care that this encounter should be recorded against
  * @param {Reference} [props.basedOn] - The ServiceRequest that initiated this encounter
  * @param {BackboneElement} [props.participant] - List of participants involved in the encounter
  * @param {Reference} [props.appointment] - The appointment that scheduled this encounter
  * @param {Period} [props.period] - The start and end time of the encounter
  * @param {Duration} [props.length] - Quantity of time the encounter lasted (less time absent)
  * @param {CodeableConcept} [props.reasonCode] - Coded reason the encounter takes place
  * @param {Reference} [props.reasonReference] - Reason the encounter takes place (reference)
  * @param {BackboneElement} [props.diagnosis] - The list of diagnosis relevant to this encounter
  * @param {Reference} [props.account] - The set of accounts that may be used for billing for this Encounter
  * @param {BackboneElement} [props.hospitalization] - Details about the admission to a healthcare service
  * @param {BackboneElement} [props.location] - List of locations where the patient has been
  * @param {Reference} [props.serviceProvider] - The organization (facility) responsible for this encounter
  * @param {Reference} [props.partOf] - Another Encounter this encounter is part of
  */
export function encounter(type: "Encounter", props: Encounter_Props);

export function encounter(props: Encounter_Props);

export function encounter(type: any, props?: any) {
    const mappings = {
        "Encounter": build_Encounter
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "Encounter";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a EnrollmentRequest resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {Identifier} [props.identifier] - Business Identifier
  * @param {string} [props.status] - active | cancelled | draft | entered-in-error
  * @param {dateTime} [props.created] - Creation date
  * @param {Reference} [props.insurer] - Target
  * @param {Reference} [props.provider] - Responsible practitioner
  * @param {Reference} [props.candidate] - The subject to be enrolled
  * @param {Reference} [props.coverage] - Insurance information
  */
export function enrollmentRequest(type: "EnrollmentRequest", props: EnrollmentRequest_Props);

export function enrollmentRequest(props: EnrollmentRequest_Props);

export function enrollmentRequest(type: any, props?: any) {
    const mappings = {
        "EnrollmentRequest": build_EnrollmentRequest
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "EnrollmentRequest";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a EnrollmentResponse resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {Identifier} [props.identifier] - Business Identifier
  * @param {string} [props.status] - active | cancelled | draft | entered-in-error
  * @param {Reference} [props.request] - Claim reference
  * @param {string} [props.outcome] - queued | complete | error | partial
  * @param {string} [props.disposition] - Disposition Message
  * @param {dateTime} [props.created] - Creation date
  * @param {Reference} [props.organization] - Insurer
  * @param {Reference} [props.requestProvider] - Responsible practitioner
  */
export function enrollmentResponse(type: "EnrollmentResponse", props: EnrollmentResponse_Props);

export function enrollmentResponse(props: EnrollmentResponse_Props);

export function enrollmentResponse(type: any, props?: any) {
    const mappings = {
        "EnrollmentResponse": build_EnrollmentResponse
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "EnrollmentResponse";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a EpisodeOfCare resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {Identifier} [props.identifier] - Business Identifier(s) relevant for this EpisodeOfCare
  * @param {string} [props.status] - planned | waitlist | active | onhold | finished | cancelled | entered-in-error
  * @param {BackboneElement} [props.statusHistory] - Past list of status codes (the current status may be included to cover the start date of the status)
  * @param {CodeableConcept} [props.type] - Type/class  - e.g. specialist referral, disease management
  * @param {BackboneElement} [props.diagnosis] - The list of diagnosis relevant to this episode of care
  * @param {Reference} [props.patient] - The patient who is the focus of this episode of care
  * @param {Reference} [props.managingOrganization] - Organization that assumes care
  * @param {Period} [props.period] - Interval during responsibility is assumed
  * @param {Reference} [props.referralRequest] - Originating Referral Request(s)
  * @param {Reference} [props.careManager] - Care manager/care coordinator for the patient
  * @param {Reference} [props.team] - Other practitioners facilitating this episode of care
  * @param {Reference} [props.account] - The set of accounts that may be used for billing for this EpisodeOfCare
  */
export function episodeOfCare(type: "EpisodeOfCare", props: EpisodeOfCare_Props);

export function episodeOfCare(props: EpisodeOfCare_Props);

export function episodeOfCare(type: any, props?: any) {
    const mappings = {
        "EpisodeOfCare": build_EpisodeOfCare
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "EpisodeOfCare";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a EventDefinition resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {string} [props.url] - Canonical identifier for this event definition, represented as a URI (globally unique)
  * @param {Identifier} [props.identifier] - Additional identifier for the event definition
  * @param {string} [props.version] - Business version of the event definition
  * @param {string} [props.name] - Name for this event definition (computer friendly)
  * @param {string} [props.title] - Name for this event definition (human friendly)
  * @param {string} [props.subtitle] - Subordinate title of the event definition
  * @param {string} [props.status] - draft | active | retired | unknown
  * @param {boolean} [props.experimental] - For testing purposes, not real usage
  * @param {CodeableConcept|Reference} [props.subject] - Type of individual the event definition is focused on
  * @param {dateTime} [props.date] - Date last changed
  * @param {string} [props.publisher] - Name of the publisher (organization or individual)
  * @param {ContactDetail} [props.contact] - Contact details for the publisher
  * @param {markdown} [props.description] - Natural language description of the event definition
  * @param {UsageContext} [props.useContext] - The context that the content is intended to support
  * @param {CodeableConcept} [props.jurisdiction] - Intended jurisdiction for event definition (if applicable)
  * @param {markdown} [props.purpose] - Why this event definition is defined
  * @param {string} [props.usage] - Describes the clinical usage of the event definition
  * @param {markdown} [props.copyright] - Use and/or publishing restrictions
  * @param {date} [props.approvalDate] - When the event definition was approved by publisher
  * @param {date} [props.lastReviewDate] - When the event definition was last reviewed
  * @param {Period} [props.effectivePeriod] - When the event definition is expected to be used
  * @param {CodeableConcept} [props.topic] - E.g. Education, Treatment, Assessment, etc.
  * @param {ContactDetail} [props.author] - Who authored the content
  * @param {ContactDetail} [props.editor] - Who edited the content
  * @param {ContactDetail} [props.reviewer] - Who reviewed the content
  * @param {ContactDetail} [props.endorser] - Who endorsed the content
  * @param {RelatedArtifact} [props.relatedArtifact] - Additional documentation, citations, etc.
  * @param {TriggerDefinition} [props.trigger] - "when" the event occurs (multiple = 'or')
  */
export function eventDefinition(type: "EventDefinition", props: EventDefinition_Props);

export function eventDefinition(props: EventDefinition_Props);

export function eventDefinition(type: any, props?: any) {
    const mappings = {
        "EventDefinition": build_EventDefinition
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "EventDefinition";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a Evidence resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {string} [props.url] - Canonical identifier for this evidence, represented as a globally unique URI
  * @param {Identifier} [props.identifier] - Additional identifier for the summary
  * @param {string} [props.version] - Business version of this summary
  * @param {string} [props.title] - Name for this summary (human friendly)
  * @param {Reference|markdown} [props.citeAs] - Citation for this evidence
  * @param {string} [props.status] - draft | active | retired | unknown
  * @param {dateTime} [props.date] - Date last changed
  * @param {UsageContext} [props.useContext] - The context that the content is intended to support
  * @param {date} [props.approvalDate] - When the summary was approved by publisher
  * @param {date} [props.lastReviewDate] - When the summary was last reviewed
  * @param {string} [props.publisher] - Name of the publisher (organization or individual)
  * @param {ContactDetail} [props.contact] - Contact details for the publisher
  * @param {ContactDetail} [props.author] - Who authored the content
  * @param {ContactDetail} [props.editor] - Who edited the content
  * @param {ContactDetail} [props.reviewer] - Who reviewed the content
  * @param {ContactDetail} [props.endorser] - Who endorsed the content
  * @param {RelatedArtifact} [props.relatedArtifact] - Link or citation to artifact associated with the summary
  * @param {markdown} [props.description] - Description of the particular summary
  * @param {markdown} [props.assertion] - Declarative description of the Evidence
  * @param {Annotation} [props.note] - Footnotes and/or explanatory notes
  * @param {BackboneElement} [props.variableDefinition] - Evidence variable such as population, exposure, or outcome
  * @param {CodeableConcept} [props.synthesisType] - The method to combine studies
  * @param {CodeableConcept} [props.studyType] - The type of study that produced this evidence
  * @param {BackboneElement} [props.statistic] - Values and parameters for a single statistic
  * @param {BackboneElement} [props.certainty] - Certainty or quality of the evidence
  */
export function evidence(type: "Evidence", props: Evidence_Props);

export function evidence(props: Evidence_Props);

export function evidence(type: any, props?: any) {
    const mappings = {
        "Evidence": build_Evidence
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "Evidence";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a EvidenceReport resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {string} [props.url] - Canonical identifier for this EvidenceReport, represented as a globally unique URI
  * @param {string} [props.status] - draft | active | retired | unknown
  * @param {UsageContext} [props.useContext] - The context that the content is intended to support
  * @param {Identifier} [props.identifier] - Unique identifier for the evidence report
  * @param {Identifier} [props.relatedIdentifier] - Identifiers for articles that may relate to more than one evidence report
  * @param {Reference|markdown} [props.citeAs] - Citation for this report
  * @param {CodeableConcept} [props.type] - Kind of report
  * @param {Annotation} [props.note] - Used for footnotes and annotations
  * @param {RelatedArtifact} [props.relatedArtifact] - Link, description or reference to artifact associated with the report
  * @param {BackboneElement} [props.subject] - Focus of the report
  * @param {string} [props.publisher] - Name of the publisher (organization or individual)
  * @param {ContactDetail} [props.contact] - Contact details for the publisher
  * @param {ContactDetail} [props.author] - Who authored the content
  * @param {ContactDetail} [props.editor] - Who edited the content
  * @param {ContactDetail} [props.reviewer] - Who reviewed the content
  * @param {ContactDetail} [props.endorser] - Who endorsed the content
  * @param {BackboneElement} [props.relatesTo] - Relationships to other compositions/documents
  * @param {BackboneElement} [props.section] - Composition is broken into sections
  */
export function evidenceReport(type: "EvidenceReport", props: EvidenceReport_Props);

export function evidenceReport(props: EvidenceReport_Props);

export function evidenceReport(type: any, props?: any) {
    const mappings = {
        "EvidenceReport": build_EvidenceReport
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "EvidenceReport";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a EvidenceVariable resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {string} [props.url] - Canonical identifier for this evidence variable, represented as a URI (globally unique)
  * @param {Identifier} [props.identifier] - Additional identifier for the evidence variable
  * @param {string} [props.version] - Business version of the evidence variable
  * @param {string} [props.name] - Name for this evidence variable (computer friendly)
  * @param {string} [props.title] - Name for this evidence variable (human friendly)
  * @param {string} [props.shortTitle] - Title for use in informal contexts
  * @param {string} [props.subtitle] - Subordinate title of the EvidenceVariable
  * @param {string} [props.status] - draft | active | retired | unknown
  * @param {dateTime} [props.date] - Date last changed
  * @param {markdown} [props.description] - Natural language description of the evidence variable
  * @param {Annotation} [props.note] - Used for footnotes or explanatory notes
  * @param {UsageContext} [props.useContext] - The context that the content is intended to support
  * @param {string} [props.publisher] - Name of the publisher (organization or individual)
  * @param {ContactDetail} [props.contact] - Contact details for the publisher
  * @param {ContactDetail} [props.author] - Who authored the content
  * @param {ContactDetail} [props.editor] - Who edited the content
  * @param {ContactDetail} [props.reviewer] - Who reviewed the content
  * @param {ContactDetail} [props.endorser] - Who endorsed the content
  * @param {RelatedArtifact} [props.relatedArtifact] - Additional documentation, citations, etc.
  * @param {boolean} [props.actual] - Actual or conceptual
  * @param {string} [props.characteristicCombination] - intersection | union
  * @param {BackboneElement} [props.characteristic] - What defines the members of the evidence element
  * @param {string} [props.handling] - continuous | dichotomous | ordinal | polychotomous
  * @param {BackboneElement} [props.category] - A grouping for ordinal or polychotomous variables
  */
export function evidenceVariable(type: "EvidenceVariable", props: EvidenceVariable_Props);

export function evidenceVariable(props: EvidenceVariable_Props);

export function evidenceVariable(type: any, props?: any) {
    const mappings = {
        "EvidenceVariable": build_EvidenceVariable
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "EvidenceVariable";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a ExplanationOfBenefit resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {Identifier} [props.identifier] - Business Identifier for the resource
  * @param {string} [props.status] - active | cancelled | draft | entered-in-error
  * @param {CodeableConcept} [props.type] - Category or discipline
  * @param {CodeableConcept} [props.subType] - More granular claim type
  * @param {string} [props.use] - claim | preauthorization | predetermination
  * @param {Reference} [props.patient] - The recipient of the products and services
  * @param {Period} [props.billablePeriod] - Relevant time frame for the claim
  * @param {dateTime} [props.created] - Response creation date
  * @param {Reference} [props.enterer] - Author of the claim
  * @param {Reference} [props.insurer] - Party responsible for reimbursement
  * @param {Reference} [props.provider] - Party responsible for the claim
  * @param {CodeableConcept} [props.priority] - Desired processing urgency
  * @param {CodeableConcept} [props.fundsReserveRequested] - For whom to reserve funds
  * @param {CodeableConcept} [props.fundsReserve] - Funds reserved status
  * @param {BackboneElement} [props.related] - Prior or corollary claims
  * @param {Reference} [props.prescription] - Prescription authorizing services or products
  * @param {Reference} [props.originalPrescription] - Original prescription if superceded by fulfiller
  * @param {BackboneElement} [props.payee] - Recipient of benefits payable
  * @param {Reference} [props.referral] - Treatment Referral
  * @param {Reference} [props.facility] - Servicing Facility
  * @param {Reference} [props.claim] - Claim reference
  * @param {Reference} [props.claimResponse] - Claim response reference
  * @param {string} [props.outcome] - queued | complete | error | partial
  * @param {string} [props.disposition] - Disposition Message
  * @param {string} [props.preAuthRef] - Preauthorization reference
  * @param {Period} [props.preAuthRefPeriod] - Preauthorization in-effect period
  * @param {BackboneElement} [props.careTeam] - Care Team members
  * @param {BackboneElement} [props.supportingInfo] - Supporting information
  * @param {BackboneElement} [props.diagnosis] - Pertinent diagnosis information
  * @param {BackboneElement} [props.procedure] - Clinical procedures performed
  * @param {number} [props.precedence] - Precedence (primary, secondary, etc.)
  * @param {BackboneElement} [props.insurance] - Patient insurance information
  * @param {BackboneElement} [props.accident] - Details of the event
  * @param {BackboneElement} [props.item] - Product or service provided
  * @param {BackboneElement} [props.addItem] - Insurer added line items
  * @param {any} [props.adjudication] - Header-level adjudication
  * @param {BackboneElement} [props.total] - Adjudication totals
  * @param {BackboneElement} [props.payment] - Payment Details
  * @param {CodeableConcept} [props.formCode] - Printed form identifier
  * @param {Attachment} [props.form] - Printed reference or actual form
  * @param {BackboneElement} [props.processNote] - Note concerning adjudication
  * @param {Period} [props.benefitPeriod] - When the benefits are applicable
  * @param {BackboneElement} [props.benefitBalance] - Balance by Benefit Category
  */
export function explanationOfBenefit(type: "ExplanationOfBenefit", props: ExplanationOfBenefit_Props);

export function explanationOfBenefit(props: ExplanationOfBenefit_Props);

export function explanationOfBenefit(type: any, props?: any) {
    const mappings = {
        "ExplanationOfBenefit": build_ExplanationOfBenefit
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "ExplanationOfBenefit";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a FamilyMemberHistory resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {Identifier} [props.identifier] - External Id(s) for this record
  * @param {canonical} [props.instantiatesCanonical] - Instantiates FHIR protocol or definition
  * @param {string} [props.instantiatesUri] - Instantiates external protocol or definition
  * @param {string} [props.status] - partial | completed | entered-in-error | health-unknown
  * @param {CodeableConcept} [props.dataAbsentReason] - subject-unknown | withheld | unable-to-obtain | deferred
  * @param {Reference} [props.patient] - Patient history is about
  * @param {dateTime} [props.date] - When history was recorded or last updated
  * @param {string} [props.name] - The family member described
  * @param {CodeableConcept} [props.relationship] - Relationship to the subject
  * @param {CodeableConcept} [props.sex] - male | female | other | unknown
  * @param {Period|date|string} [props.born] - (approximate) date of birth
  * @param {Age|Range|string} [props.age] - (approximate) age
  * @param {boolean} [props.estimatedAge] - Age is estimated?
  * @param {boolean|Age|Range|date|string} [props.deceased] - Dead? How old/when?
  * @param {CodeableConcept} [props.reasonCode] - Why was family member history performed?
  * @param {Reference} [props.reasonReference] - Why was family member history performed?
  * @param {Annotation} [props.note] - General note about related person
  * @param {BackboneElement} [props.condition] - Condition that the related person had
  */
export function familyMemberHistory(type: "FamilyMemberHistory", props: FamilyMemberHistory_Props);

export function familyMemberHistory(props: FamilyMemberHistory_Props);

export function familyMemberHistory(type: any, props?: any) {
    const mappings = {
        "FamilyMemberHistory": build_FamilyMemberHistory
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "FamilyMemberHistory";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a Flag resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {Identifier} [props.identifier] - Business identifier
  * @param {string} [props.status] - active | inactive | entered-in-error
  * @param {CodeableConcept} [props.category] - Clinical, administrative, etc.
  * @param {CodeableConcept} [props.code] - Coded or textual message to display to user
  * @param {Reference} [props.subject] - Who/What is flag about?
  * @param {Period} [props.period] - Time period when flag is active
  * @param {Reference} [props.encounter] - Alert relevant during encounter
  * @param {Reference} [props.author] - Flag creator
  */
export function flag(type: "Flag", props: Flag_Props);

export function flag(props: Flag_Props);

export function flag(type: any, props?: any) {
    const mappings = {
        "Flag": build_Flag
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "Flag";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a Goal resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {Identifier} [props.identifier] - External Ids for this goal
  * @param {string} [props.lifecycleStatus] - proposed | planned | accepted | active | on-hold | completed | cancelled | entered-in-error | rejected
  * @param {CodeableConcept} [props.achievementStatus] - in-progress | improving | worsening | no-change | achieved | sustaining | not-achieved | no-progress | not-attainable
  * @param {CodeableConcept} [props.category] - E.g. Treatment, dietary, behavioral, etc.
  * @param {CodeableConcept} [props.priority] - high-priority | medium-priority | low-priority
  * @param {CodeableConcept} [props.description] - Code or text describing goal
  * @param {Reference} [props.subject] - Who this goal is intended for
  * @param {date|CodeableConcept} [props.start] - When goal pursuit begins
  * @param {BackboneElement} [props.target] - Target outcome for the goal
  * @param {date} [props.statusDate] - When goal status took effect
  * @param {string} [props.statusReason] - Reason for current status
  * @param {Reference} [props.expressedBy] - Who's responsible for creating Goal?
  * @param {Reference} [props.addresses] - Issues addressed by this goal
  * @param {Annotation} [props.note] - Comments about the goal
  * @param {CodeableConcept} [props.outcomeCode] - What result was achieved regarding the goal?
  * @param {Reference} [props.outcomeReference] - Observation that resulted from goal
  */
export function goal(type: "Goal", props: Goal_Props);

export function goal(props: Goal_Props);

export function goal(type: any, props?: any) {
    const mappings = {
        "Goal": build_Goal
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "Goal";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a Group resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {Identifier} [props.identifier] - Unique id
  * @param {boolean} [props.active] - Whether this group's record is in active use
  * @param {string} [props.type] - person | animal | practitioner | device | medication | substance
  * @param {boolean} [props.actual] - Descriptive or actual
  * @param {CodeableConcept} [props.code] - Kind of Group members
  * @param {string} [props.name] - Label for Group
  * @param {unsignedInt} [props.quantity] - Number of members
  * @param {Reference} [props.managingEntity] - Entity that is the custodian of the Group's definition
  * @param {BackboneElement} [props.characteristic] - Include / Exclude group members by Trait
  * @param {BackboneElement} [props.member] - Who or what is in group
  */
export function group(type: "Group", props: Group_Props);

export function group(props: Group_Props);

export function group(type: any, props?: any) {
    const mappings = {
        "Group": build_Group
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "Group";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a GuidanceResponse resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {Identifier} [props.requestIdentifier] - The identifier of the request associated with this response, if any
  * @param {Identifier} [props.identifier] - Business identifier
  * @param {string|canonical|CodeableConcept} [props.module] - What guidance was requested
  * @param {string} [props.status] - success | data-requested | data-required | in-progress | failure | entered-in-error
  * @param {Reference} [props.subject] - Patient the request was performed for
  * @param {Reference} [props.encounter] - Encounter during which the response was returned
  * @param {dateTime} [props.occurrenceDateTime] - When the guidance response was processed
  * @param {Reference} [props.performer] - Device returning the guidance
  * @param {CodeableConcept} [props.reasonCode] - Why guidance is needed
  * @param {Reference} [props.reasonReference] - Why guidance is needed
  * @param {Annotation} [props.note] - Additional notes about the response
  * @param {Reference} [props.evaluationMessage] - Messages resulting from the evaluation of the artifact or artifacts
  * @param {Reference} [props.outputParameters] - The output parameters of the evaluation, if any
  * @param {Reference} [props.result] - Proposed actions, if any
  * @param {DataRequirement} [props.dataRequirement] - Additional required data
  */
export function guidanceResponse(type: "GuidanceResponse", props: GuidanceResponse_Props);

export function guidanceResponse(props: GuidanceResponse_Props);

export function guidanceResponse(type: any, props?: any) {
    const mappings = {
        "GuidanceResponse": build_GuidanceResponse
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "GuidanceResponse";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a HealthcareService resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {Identifier} [props.identifier] - External identifiers for this item
  * @param {boolean} [props.active] - Whether this HealthcareService record is in active use
  * @param {Reference} [props.providedBy] - Organization that provides this service
  * @param {CodeableConcept} [props.category] - Broad category of service being performed or delivered
  * @param {CodeableConcept} [props.type] - Type of service that may be delivered or performed
  * @param {CodeableConcept} [props.specialty] - Specialties handled by the HealthcareService
  * @param {Reference} [props.location] - Location(s) where service may be provided
  * @param {string} [props.name] - Description of service as presented to a consumer while searching
  * @param {string} [props.comment] - Additional description and/or any specific issues not covered elsewhere
  * @param {markdown} [props.extraDetails] - Extra details about the service that can't be placed in the other fields
  * @param {Attachment} [props.photo] - Facilitates quick identification of the service
  * @param {ContactPoint} [props.telecom] - Contacts related to the healthcare service
  * @param {Reference} [props.coverageArea] - Location(s) service is intended for/available to
  * @param {CodeableConcept} [props.serviceProvisionCode] - Conditions under which service is available/offered
  * @param {BackboneElement} [props.eligibility] - Specific eligibility requirements required to use the service
  * @param {CodeableConcept} [props.program] - Programs that this service is applicable to
  * @param {CodeableConcept} [props.characteristic] - Collection of characteristics (attributes)
  * @param {CodeableConcept} [props.communication] - The language that this service is offered in
  * @param {CodeableConcept} [props.referralMethod] - Ways that the service accepts referrals
  * @param {boolean} [props.appointmentRequired] - If an appointment is required for access to this service
  * @param {BackboneElement} [props.availableTime] - Times the Service Site is available
  * @param {BackboneElement} [props.notAvailable] - Not available during this time due to provided reason
  * @param {string} [props.availabilityExceptions] - Description of availability exceptions
  * @param {Reference} [props.endpoint] - Technical endpoints providing access to electronic services operated for the healthcare service
  */
export function healthcareService(type: "HealthcareService", props: HealthcareService_Props);

export function healthcareService(props: HealthcareService_Props);

export function healthcareService(type: any, props?: any) {
    const mappings = {
        "HealthcareService": build_HealthcareService
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "HealthcareService";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a ImagingStudy resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {Identifier} [props.identifier] - Identifiers for the whole study
  * @param {string} [props.status] - registered | available | cancelled | entered-in-error | unknown
  * @param {Coding} [props.modality] - All series modality if actual acquisition modalities
  * @param {Reference} [props.subject] - Who or what is the subject of the study
  * @param {Reference} [props.encounter] - Encounter with which this imaging study is associated
  * @param {dateTime} [props.started] - When the study was started
  * @param {Reference} [props.basedOn] - Request fulfilled
  * @param {Reference} [props.referrer] - Referring physician
  * @param {Reference} [props.interpreter] - Who interpreted images
  * @param {Reference} [props.endpoint] - Study access endpoint
  * @param {unsignedInt} [props.numberOfSeries] - Number of Study Related Series
  * @param {unsignedInt} [props.numberOfInstances] - Number of Study Related Instances
  * @param {Reference} [props.procedureReference] - The performed Procedure reference
  * @param {CodeableConcept} [props.procedureCode] - The performed procedure code
  * @param {Reference} [props.location] - Where ImagingStudy occurred
  * @param {CodeableConcept} [props.reasonCode] - Why the study was requested
  * @param {Reference} [props.reasonReference] - Why was study performed
  * @param {Annotation} [props.note] - User-defined comments
  * @param {string} [props.description] - Institution-generated description
  * @param {BackboneElement} [props.series] - Each study has one or more series of instances
  */
export function imagingStudy(type: "ImagingStudy", props: ImagingStudy_Props);

export function imagingStudy(props: ImagingStudy_Props);

export function imagingStudy(type: any, props?: any) {
    const mappings = {
        "ImagingStudy": build_ImagingStudy
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "ImagingStudy";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a Immunization resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {Identifier} [props.identifier] - Business identifier
  * @param {string} [props.status] - completed | entered-in-error | not-done
  * @param {CodeableConcept} [props.statusReason] - Reason not done
  * @param {CodeableConcept} [props.vaccineCode] - Vaccine product administered
  * @param {Reference} [props.patient] - Who was immunized
  * @param {Reference} [props.encounter] - Encounter immunization was part of
  * @param {dateTime|string} [props.occurrence] - Vaccine administration date
  * @param {dateTime} [props.recorded] - When the immunization was first captured in the subject's record
  * @param {boolean} [props.primarySource] - Indicates context the data was recorded in
  * @param {CodeableConcept} [props.reportOrigin] - Indicates the source of a secondarily reported record
  * @param {Reference} [props.location] - Where immunization occurred
  * @param {Reference} [props.manufacturer] - Vaccine manufacturer
  * @param {string} [props.lotNumber] - Vaccine lot number
  * @param {date} [props.expirationDate] - Vaccine expiration date
  * @param {CodeableConcept} [props.site] - Body site vaccine  was administered
  * @param {CodeableConcept} [props.route] - How vaccine entered body
  * @param {Quantity} [props.doseQuantity] - Amount of vaccine administered
  * @param {BackboneElement} [props.performer] - Who performed event
  * @param {Annotation} [props.note] - Additional immunization notes
  * @param {CodeableConcept} [props.reasonCode] - Why immunization occurred
  * @param {Reference} [props.reasonReference] - Why immunization occurred
  * @param {boolean} [props.isSubpotent] - Dose potency
  * @param {CodeableConcept} [props.subpotentReason] - Reason for being subpotent
  * @param {BackboneElement} [props.education] - Educational material presented to patient
  * @param {CodeableConcept} [props.programEligibility] - Patient eligibility for a vaccination program
  * @param {CodeableConcept} [props.fundingSource] - Funding source for the vaccine
  * @param {BackboneElement} [props.reaction] - Details of a reaction that follows immunization
  * @param {BackboneElement} [props.protocolApplied] - Protocol followed by the provider
  */
export function immunization(type: "Immunization", props: Immunization_Props);

export function immunization(props: Immunization_Props);

export function immunization(type: any, props?: any) {
    const mappings = {
        "Immunization": build_Immunization
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "Immunization";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a ImmunizationEvaluation resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {Identifier} [props.identifier] - Business identifier
  * @param {string} [props.status] - completed | entered-in-error
  * @param {Reference} [props.patient] - Who this evaluation is for
  * @param {dateTime} [props.date] - Date evaluation was performed
  * @param {Reference} [props.authority] - Who is responsible for publishing the recommendations
  * @param {CodeableConcept} [props.targetDisease] - Evaluation target disease
  * @param {Reference} [props.immunizationEvent] - Immunization being evaluated
  * @param {CodeableConcept} [props.doseStatus] - Status of the dose relative to published recommendations
  * @param {CodeableConcept} [props.doseStatusReason] - Reason for the dose status
  * @param {string} [props.description] - Evaluation notes
  * @param {string} [props.series] - Name of vaccine series
  * @param {number|string} [props.doseNumber] - Dose number within series
  * @param {number|string} [props.seriesDoses] - Recommended number of doses for immunity
  */
export function immunizationEvaluation(type: "ImmunizationEvaluation", props: ImmunizationEvaluation_Props);

export function immunizationEvaluation(props: ImmunizationEvaluation_Props);

export function immunizationEvaluation(type: any, props?: any) {
    const mappings = {
        "ImmunizationEvaluation": build_ImmunizationEvaluation
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "ImmunizationEvaluation";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a ImmunizationRecommendation resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {Identifier} [props.identifier] - Business identifier
  * @param {Reference} [props.patient] - Who this profile is for
  * @param {dateTime} [props.date] - Date recommendation(s) created
  * @param {Reference} [props.authority] - Who is responsible for protocol
  * @param {BackboneElement} [props.recommendation] - Vaccine administration recommendations
  */
export function immunizationRecommendation(
    type: "ImmunizationRecommendation",
    props: ImmunizationRecommendation_Props
);

export function immunizationRecommendation(props: ImmunizationRecommendation_Props);

export function immunizationRecommendation(type: any, props?: any) {
    const mappings = {
        "ImmunizationRecommendation": build_ImmunizationRecommendation
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "ImmunizationRecommendation";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a Ingredient resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {Identifier} [props.identifier] - An identifier or code by which the ingredient can be referenced
  * @param {string} [props.status] - draft | active | retired | unknown
  * @param {Reference} [props.for] - The product which this ingredient is a constituent part of
  * @param {CodeableConcept} [props.role] - Purpose of the ingredient within the product, e.g. active, inactive
  * @param {CodeableConcept} [props.function] - Precise action within the drug product, e.g. antioxidant, alkalizing agent
  * @param {boolean} [props.allergenicIndicator] - If the ingredient is a known or suspected allergen
  * @param {BackboneElement} [props.manufacturer] - An organization that manufactures this ingredient
  * @param {BackboneElement} [props.substance] - The substance that comprises this ingredient
  */
export function ingredient(type: "Ingredient", props: Ingredient_Props);

export function ingredient(props: Ingredient_Props);

export function ingredient(type: any, props?: any) {
    const mappings = {
        "Ingredient": build_Ingredient
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "Ingredient";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a InsurancePlan resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {Identifier} [props.identifier] - Business Identifier for Product
  * @param {string} [props.status] - draft | active | retired | unknown
  * @param {CodeableConcept} [props.type] - Kind of product
  * @param {string} [props.name] - Official name
  * @param {string} [props.alias] - Alternate names
  * @param {Period} [props.period] - When the product is available
  * @param {Reference} [props.ownedBy] - Plan issuer
  * @param {Reference} [props.administeredBy] - Product administrator
  * @param {Reference} [props.coverageArea] - Where product applies
  * @param {BackboneElement} [props.contact] - Contact for the product
  * @param {Reference} [props.endpoint] - Technical endpoint
  * @param {Reference} [props.network] - What networks are Included
  * @param {BackboneElement} [props.coverage] - Coverage details
  * @param {BackboneElement} [props.plan] - Plan details
  */
export function insurancePlan(type: "InsurancePlan", props: InsurancePlan_Props);

export function insurancePlan(props: InsurancePlan_Props);

export function insurancePlan(type: any, props?: any) {
    const mappings = {
        "InsurancePlan": build_InsurancePlan
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "InsurancePlan";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a Invoice resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {Identifier} [props.identifier] - Business Identifier for item
  * @param {string} [props.status] - draft | issued | balanced | cancelled | entered-in-error
  * @param {string} [props.cancelledReason] - Reason for cancellation of this Invoice
  * @param {CodeableConcept} [props.type] - Type of Invoice
  * @param {Reference} [props.subject] - Recipient(s) of goods and services
  * @param {Reference} [props.recipient] - Recipient of this invoice
  * @param {dateTime} [props.date] - Invoice date / posting date
  * @param {BackboneElement} [props.participant] - Participant in creation of this Invoice
  * @param {Reference} [props.issuer] - Issuing Organization of Invoice
  * @param {Reference} [props.account] - Account that is being balanced
  * @param {BackboneElement} [props.lineItem] - Line items of this Invoice
  * @param {any} [props.totalPriceComponent] - Components of Invoice total
  * @param {Money} [props.totalNet] - Net total of this Invoice
  * @param {Money} [props.totalGross] - Gross total of this Invoice
  * @param {markdown} [props.paymentTerms] - Payment details
  * @param {Annotation} [props.note] - Comments made about the invoice
  */
export function invoice(type: "Invoice", props: Invoice_Props);

export function invoice(props: Invoice_Props);

export function invoice(type: any, props?: any) {
    const mappings = {
        "Invoice": build_Invoice
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "Invoice";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a Library resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {string} [props.url] - Canonical identifier for this library, represented as a URI (globally unique)
  * @param {Identifier} [props.identifier] - Additional identifier for the library
  * @param {string} [props.version] - Business version of the library
  * @param {string} [props.name] - Name for this library (computer friendly)
  * @param {string} [props.title] - Name for this library (human friendly)
  * @param {string} [props.subtitle] - Subordinate title of the library
  * @param {string} [props.status] - draft | active | retired | unknown
  * @param {boolean} [props.experimental] - For testing purposes, not real usage
  * @param {CodeableConcept} [props.type] - logic-library | model-definition | asset-collection | module-definition
  * @param {CodeableConcept|Reference} [props.subject] - Type of individual the library content is focused on
  * @param {dateTime} [props.date] - Date last changed
  * @param {string} [props.publisher] - Name of the publisher (organization or individual)
  * @param {ContactDetail} [props.contact] - Contact details for the publisher
  * @param {markdown} [props.description] - Natural language description of the library
  * @param {UsageContext} [props.useContext] - The context that the content is intended to support
  * @param {CodeableConcept} [props.jurisdiction] - Intended jurisdiction for library (if applicable)
  * @param {markdown} [props.purpose] - Why this library is defined
  * @param {string} [props.usage] - Describes the clinical usage of the library
  * @param {markdown} [props.copyright] - Use and/or publishing restrictions
  * @param {date} [props.approvalDate] - When the library was approved by publisher
  * @param {date} [props.lastReviewDate] - When the library was last reviewed
  * @param {Period} [props.effectivePeriod] - When the library is expected to be used
  * @param {CodeableConcept} [props.topic] - E.g. Education, Treatment, Assessment, etc.
  * @param {ContactDetail} [props.author] - Who authored the content
  * @param {ContactDetail} [props.editor] - Who edited the content
  * @param {ContactDetail} [props.reviewer] - Who reviewed the content
  * @param {ContactDetail} [props.endorser] - Who endorsed the content
  * @param {RelatedArtifact} [props.relatedArtifact] - Additional documentation, citations, etc.
  * @param {ParameterDefinition} [props.parameter] - Parameters defined by the library
  * @param {DataRequirement} [props.dataRequirement] - What data is referenced by this library
  * @param {Attachment} [props.content] - Contents of the library, either embedded or referenced
  */
export function library(type: "Library", props: Library_Props);

export function library(props: Library_Props);

export function library(type: any, props?: any) {
    const mappings = {
        "Library": build_Library
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "Library";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a List resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {Identifier} [props.identifier] - Business identifier
  * @param {string} [props.status] - current | retired | entered-in-error
  * @param {string} [props.mode] - working | snapshot | changes
  * @param {string} [props.title] - Descriptive name for the list
  * @param {CodeableConcept} [props.code] - What the purpose of this list is
  * @param {Reference} [props.subject] - If all resources have the same subject
  * @param {Reference} [props.encounter] - Context in which list created
  * @param {dateTime} [props.date] - When the list was prepared
  * @param {Reference} [props.source] - Who and/or what defined the list contents (aka Author)
  * @param {CodeableConcept} [props.orderedBy] - What order the list has
  * @param {Annotation} [props.note] - Comments about the list
  * @param {BackboneElement} [props.entry] - Entries in the list
  * @param {CodeableConcept} [props.emptyReason] - Why list is empty
  */
export function list(type: "List", props: List_Props);

export function list(props: List_Props);

export function list(type: any, props?: any) {
    const mappings = {
        "List": build_List
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "List";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a Location resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {Identifier} [props.identifier] - Unique code or number identifying the location to its users
  * @param {string} [props.status] - active | suspended | inactive
  * @param {Coding} [props.operationalStatus] - The operational status of the location (typically only for a bed/room)
  * @param {string} [props.name] - Name of the location as used by humans
  * @param {string} [props.alias] - A list of alternate names that the location is known as, or was known as, in the past
  * @param {string} [props.description] - Additional details about the location that could be displayed as further information to identify the location beyond its name
  * @param {string} [props.mode] - instance | kind
  * @param {CodeableConcept} [props.type] - Type of function performed
  * @param {ContactPoint} [props.telecom] - Contact details of the location
  * @param {Address} [props.address] - Physical location
  * @param {CodeableConcept} [props.physicalType] - Physical form of the location
  * @param {BackboneElement} [props.position] - The absolute geographic location
  * @param {Reference} [props.managingOrganization] - Organization responsible for provisioning and upkeep
  * @param {Reference} [props.partOf] - Another Location this one is physically a part of
  * @param {BackboneElement} [props.hoursOfOperation] - What days/times during a week is this location usually open
  * @param {string} [props.availabilityExceptions] - Description of availability exceptions
  * @param {Reference} [props.endpoint] - Technical endpoints providing access to services operated for the location
  */
export function location(type: "Location", props: Location_Props);

export function location(props: Location_Props);

export function location(type: any, props?: any) {
    const mappings = {
        "Location": build_Location
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "Location";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a ManufacturedItemDefinition resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {Identifier} [props.identifier] - Unique identifier
  * @param {string} [props.status] - draft | active | retired | unknown
  * @param {CodeableConcept} [props.manufacturedDoseForm] - Dose form as manufactured (before any necessary transformation)
  * @param {CodeableConcept} [props.unitOfPresentation] - The real world units in which the quantity of the item is described
  * @param {Reference} [props.manufacturer] - Manufacturer of the item (Note that this should be named "manufacturer" but it currently causes technical issues)
  * @param {CodeableConcept} [props.ingredient] - The ingredients of this manufactured item. Only needed if these are not specified by incoming references from the Ingredient resource
  * @param {BackboneElement} [props.property] - General characteristics of this item
  */
export function manufacturedItemDefinition(
    type: "ManufacturedItemDefinition",
    props: ManufacturedItemDefinition_Props
);

export function manufacturedItemDefinition(props: ManufacturedItemDefinition_Props);

export function manufacturedItemDefinition(type: any, props?: any) {
    const mappings = {
        "ManufacturedItemDefinition": build_ManufacturedItemDefinition
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "ManufacturedItemDefinition";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a Measure resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {string} [props.url] - Canonical identifier for this measure, represented as a URI (globally unique)
  * @param {Identifier} [props.identifier] - Additional identifier for the measure
  * @param {string} [props.version] - Business version of the measure
  * @param {string} [props.name] - Name for this measure (computer friendly)
  * @param {string} [props.title] - Name for this measure (human friendly)
  * @param {string} [props.subtitle] - Subordinate title of the measure
  * @param {string} [props.status] - draft | active | retired | unknown
  * @param {boolean} [props.experimental] - For testing purposes, not real usage
  * @param {CodeableConcept|Reference} [props.subject] - E.g. Patient, Practitioner, RelatedPerson, Organization, Location, Device
  * @param {dateTime} [props.date] - Date last changed
  * @param {string} [props.publisher] - Name of the publisher (organization or individual)
  * @param {ContactDetail} [props.contact] - Contact details for the publisher
  * @param {markdown} [props.description] - Natural language description of the measure
  * @param {UsageContext} [props.useContext] - The context that the content is intended to support
  * @param {CodeableConcept} [props.jurisdiction] - Intended jurisdiction for measure (if applicable)
  * @param {markdown} [props.purpose] - Why this measure is defined
  * @param {string} [props.usage] - Describes the clinical usage of the measure
  * @param {markdown} [props.copyright] - Use and/or publishing restrictions
  * @param {date} [props.approvalDate] - When the measure was approved by publisher
  * @param {date} [props.lastReviewDate] - When the measure was last reviewed
  * @param {Period} [props.effectivePeriod] - When the measure is expected to be used
  * @param {CodeableConcept} [props.topic] - The category of the measure, such as Education, Treatment, Assessment, etc.
  * @param {ContactDetail} [props.author] - Who authored the content
  * @param {ContactDetail} [props.editor] - Who edited the content
  * @param {ContactDetail} [props.reviewer] - Who reviewed the content
  * @param {ContactDetail} [props.endorser] - Who endorsed the content
  * @param {RelatedArtifact} [props.relatedArtifact] - Additional documentation, citations, etc.
  * @param {canonical} [props.library] - Logic used by the measure
  * @param {markdown} [props.disclaimer] - Disclaimer for use of the measure or its referenced content
  * @param {CodeableConcept} [props.scoring] - proportion | ratio | continuous-variable | cohort
  * @param {CodeableConcept} [props.compositeScoring] - opportunity | all-or-nothing | linear | weighted
  * @param {CodeableConcept} [props.type] - process | outcome | structure | patient-reported-outcome | composite
  * @param {string} [props.riskAdjustment] - How risk adjustment is applied for this measure
  * @param {string} [props.rateAggregation] - How is rate aggregation performed for this measure
  * @param {markdown} [props.rationale] - Detailed description of why the measure exists
  * @param {markdown} [props.clinicalRecommendationStatement] - Summary of clinical guidelines
  * @param {CodeableConcept} [props.improvementNotation] - increase | decrease
  * @param {markdown} [props.definition] - Defined terms used in the measure documentation
  * @param {markdown} [props.guidance] - Additional guidance for implementers
  * @param {BackboneElement} [props.group] - Population criteria group
  * @param {BackboneElement} [props.supplementalData] - What other data should be reported with the measure
  */
export function measure(type: "Measure", props: Measure_Props);

export function measure(props: Measure_Props);

export function measure(type: any, props?: any) {
    const mappings = {
        "Measure": build_Measure
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "Measure";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a MeasureReport resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {Identifier} [props.identifier] - Additional identifier for the MeasureReport
  * @param {string} [props.status] - complete | pending | error
  * @param {string} [props.type] - individual | subject-list | summary | data-collection
  * @param {canonical} [props.measure] - What measure was calculated
  * @param {Reference} [props.subject] - What individual(s) the report is for
  * @param {dateTime} [props.date] - When the report was generated
  * @param {Reference} [props.reporter] - Who is reporting the data
  * @param {Period} [props.period] - What period the report covers
  * @param {CodeableConcept} [props.improvementNotation] - increase | decrease
  * @param {BackboneElement} [props.group] - Measure results for each group
  * @param {Reference} [props.evaluatedResource] - What data was used to calculate the measure score
  */
export function measureReport(type: "MeasureReport", props: MeasureReport_Props);

export function measureReport(props: MeasureReport_Props);

export function measureReport(type: any, props?: any) {
    const mappings = {
        "MeasureReport": build_MeasureReport
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "MeasureReport";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a Media resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {Identifier} [props.identifier] - Identifier(s) for the image
  * @param {Reference} [props.basedOn] - Procedure that caused this media to be created
  * @param {Reference} [props.partOf] - Part of referenced event
  * @param {string} [props.status] - preparation | in-progress | not-done | on-hold | stopped | completed | entered-in-error | unknown
  * @param {CodeableConcept} [props.type] - Classification of media as image, video, or audio
  * @param {CodeableConcept} [props.modality] - The type of acquisition equipment/process
  * @param {CodeableConcept} [props.view] - Imaging view, e.g. Lateral or Antero-posterior
  * @param {Reference} [props.subject] - Who/What this Media is a record of
  * @param {Reference} [props.encounter] - Encounter associated with media
  * @param {dateTime|Period} [props.created] - When Media was collected
  * @param {instant} [props.issued] - Date/Time this version was made available
  * @param {Reference} [props.operator] - The person who generated the image
  * @param {CodeableConcept} [props.reasonCode] - Why was event performed?
  * @param {CodeableConcept} [props.bodySite] - Observed body part
  * @param {string} [props.deviceName] - Name of the device/manufacturer
  * @param {Reference} [props.device] - Observing Device
  * @param {number} [props.height] - Height of the image in pixels (photo/video)
  * @param {number} [props.width] - Width of the image in pixels (photo/video)
  * @param {number} [props.frames] - Number of frames if > 1 (photo)
  * @param {decimal} [props.duration] - Length in seconds (audio / video)
  * @param {Attachment} [props.content] - Actual Media - reference or data
  * @param {Annotation} [props.note] - Comments made about the media
  */
export function media(type: "Media", props: Media_Props);

export function media(props: Media_Props);

export function media(type: any, props?: any) {
    const mappings = {
        "Media": build_Media
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "Media";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a Medication resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {Identifier} [props.identifier] - Business identifier for this medication
  * @param {CodeableConcept} [props.code] - Codes that identify this medication
  * @param {string} [props.status] - active | inactive | entered-in-error
  * @param {Reference} [props.manufacturer] - Manufacturer of the item
  * @param {CodeableConcept} [props.form] - powder | tablets | capsule +
  * @param {Ratio} [props.amount] - Amount of drug in package
  * @param {BackboneElement} [props.ingredient] - Active or inactive ingredient
  * @param {BackboneElement} [props.batch] - Details about packaged medications
  */
export function medication(type: "Medication", props: Medication_Props);

export function medication(props: Medication_Props);

export function medication(type: any, props?: any) {
    const mappings = {
        "Medication": build_Medication
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "Medication";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a MedicationAdministration resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {Identifier} [props.identifier] - External identifier
  * @param {string} [props.instantiates] - Instantiates protocol or definition
  * @param {Reference} [props.partOf] - Part of referenced event
  * @param {string} [props.status] - in-progress | not-done | on-hold | completed | entered-in-error | stopped | unknown
  * @param {CodeableConcept} [props.statusReason] - Reason administration not performed
  * @param {CodeableConcept} [props.category] - Type of medication usage
  * @param {CodeableConcept|Reference} [props.medication] - What was administered
  * @param {Reference} [props.subject] - Who received medication
  * @param {Reference} [props.context] - Encounter or Episode of Care administered as part of
  * @param {Reference} [props.supportingInformation] - Additional information to support administration
  * @param {dateTime|Period} [props.effective] - Start and end time of administration
  * @param {BackboneElement} [props.performer] - Who performed the medication administration and what they did
  * @param {CodeableConcept} [props.reasonCode] - Reason administration performed
  * @param {Reference} [props.reasonReference] - Condition or observation that supports why the medication was administered
  * @param {Reference} [props.request] - Request administration performed against
  * @param {Reference} [props.device] - Device used to administer
  * @param {Annotation} [props.note] - Information about the administration
  * @param {BackboneElement} [props.dosage] - Details of how medication was taken
  * @param {Reference} [props.eventHistory] - A list of events of interest in the lifecycle
  */
export function medicationAdministration(type: "MedicationAdministration", props: MedicationAdministration_Props);

export function medicationAdministration(props: MedicationAdministration_Props);

export function medicationAdministration(type: any, props?: any) {
    const mappings = {
        "MedicationAdministration": build_MedicationAdministration
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "MedicationAdministration";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a MedicationDispense resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {Identifier} [props.identifier] - External identifier
  * @param {Reference} [props.partOf] - Event that dispense is part of
  * @param {string} [props.status] - preparation | in-progress | cancelled | on-hold | completed | entered-in-error | stopped | declined | unknown
  * @param {CodeableConcept|Reference} [props.statusReason] - Why a dispense was not performed
  * @param {CodeableConcept} [props.category] - Type of medication dispense
  * @param {CodeableConcept|Reference} [props.medication] - What medication was supplied
  * @param {Reference} [props.subject] - Who the dispense is for
  * @param {Reference} [props.context] - Encounter / Episode associated with event
  * @param {Reference} [props.supportingInformation] - Information that supports the dispensing of the medication
  * @param {BackboneElement} [props.performer] - Who performed event
  * @param {Reference} [props.location] - Where the dispense occurred
  * @param {Reference} [props.authorizingPrescription] - Medication order that authorizes the dispense
  * @param {CodeableConcept} [props.type] - Trial fill, partial fill, emergency fill, etc.
  * @param {Quantity} [props.quantity] - Amount dispensed
  * @param {Quantity} [props.daysSupply] - Amount of medication expressed as a timing amount
  * @param {dateTime} [props.whenPrepared] - When product was packaged and reviewed
  * @param {dateTime} [props.whenHandedOver] - When product was given out
  * @param {Reference} [props.destination] - Where the medication was sent
  * @param {Reference} [props.receiver] - Who collected the medication
  * @param {Annotation} [props.note] - Information about the dispense
  * @param {Dosage} [props.dosageInstruction] - How the medication is to be used by the patient or administered by the caregiver
  * @param {BackboneElement} [props.substitution] - Whether a substitution was performed on the dispense
  * @param {Reference} [props.detectedIssue] - Clinical issue with action
  * @param {Reference} [props.eventHistory] - A list of relevant lifecycle events
  */
export function medicationDispense(type: "MedicationDispense", props: MedicationDispense_Props);

export function medicationDispense(props: MedicationDispense_Props);

export function medicationDispense(type: any, props?: any) {
    const mappings = {
        "MedicationDispense": build_MedicationDispense
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "MedicationDispense";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a MedicationKnowledge resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {CodeableConcept} [props.code] - Code that identifies this medication
  * @param {string} [props.status] - active | inactive | entered-in-error
  * @param {Reference} [props.manufacturer] - Manufacturer of the item
  * @param {CodeableConcept} [props.doseForm] - powder | tablets | capsule +
  * @param {Quantity} [props.amount] - Amount of drug in package
  * @param {string} [props.synonym] - Additional names for a medication
  * @param {BackboneElement} [props.relatedMedicationKnowledge] - Associated or related medication information
  * @param {Reference} [props.associatedMedication] - A medication resource that is associated with this medication
  * @param {CodeableConcept} [props.productType] - Category of the medication or product
  * @param {BackboneElement} [props.monograph] - Associated documentation about the medication
  * @param {BackboneElement} [props.ingredient] - Active or inactive ingredient
  * @param {markdown} [props.preparationInstruction] - The instructions for preparing the medication
  * @param {CodeableConcept} [props.intendedRoute] - The intended or approved route of administration
  * @param {BackboneElement} [props.cost] - The pricing of the medication
  * @param {BackboneElement} [props.monitoringProgram] - Program under which a medication is reviewed
  * @param {BackboneElement} [props.administrationGuidelines] - Guidelines for administration of the medication
  * @param {BackboneElement} [props.medicineClassification] - Categorization of the medication within a formulary or classification system
  * @param {BackboneElement} [props.packaging] - Details about packaged medications
  * @param {BackboneElement} [props.drugCharacteristic] - Specifies descriptive properties of the medicine
  * @param {Reference} [props.contraindication] - Potential clinical issue with or between medication(s)
  * @param {BackboneElement} [props.regulatory] - Regulatory information about a medication
  * @param {BackboneElement} [props.kinetics] - The time course of drug absorption, distribution, metabolism and excretion of a medication from the body
  */
export function medicationKnowledge(type: "MedicationKnowledge", props: MedicationKnowledge_Props);

export function medicationKnowledge(props: MedicationKnowledge_Props);

export function medicationKnowledge(type: any, props?: any) {
    const mappings = {
        "MedicationKnowledge": build_MedicationKnowledge
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "MedicationKnowledge";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a MedicationRequest resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {Identifier} [props.identifier] - External ids for this request
  * @param {string} [props.status] - active | on-hold | cancelled | completed | entered-in-error | stopped | draft | unknown
  * @param {CodeableConcept} [props.statusReason] - Reason for current status
  * @param {string} [props.intent] - proposal | plan | order | original-order | reflex-order | filler-order | instance-order | option
  * @param {CodeableConcept} [props.category] - Type of medication usage
  * @param {string} [props.priority] - routine | urgent | asap | stat
  * @param {boolean} [props.doNotPerform] - True if request is prohibiting action
  * @param {boolean|Reference} [props.reported] - Reported rather than primary record
  * @param {CodeableConcept|Reference} [props.medication] - Medication to be taken
  * @param {Reference} [props.subject] - Who or group medication request is for
  * @param {Reference} [props.encounter] - Encounter created as part of encounter/admission/stay
  * @param {Reference} [props.supportingInformation] - Information to support ordering of the medication
  * @param {dateTime} [props.authoredOn] - When request was initially authored
  * @param {Reference} [props.requester] - Who/What requested the Request
  * @param {Reference} [props.performer] - Intended performer of administration
  * @param {CodeableConcept} [props.performerType] - Desired kind of performer of the medication administration
  * @param {Reference} [props.recorder] - Person who entered the request
  * @param {CodeableConcept} [props.reasonCode] - Reason or indication for ordering or not ordering the medication
  * @param {Reference} [props.reasonReference] - Condition or observation that supports why the prescription is being written
  * @param {canonical} [props.instantiatesCanonical] - Instantiates FHIR protocol or definition
  * @param {string} [props.instantiatesUri] - Instantiates external protocol or definition
  * @param {Reference} [props.basedOn] - What request fulfills
  * @param {Identifier} [props.groupIdentifier] - Composite request this is part of
  * @param {CodeableConcept} [props.courseOfTherapyType] - Overall pattern of medication administration
  * @param {Reference} [props.insurance] - Associated insurance coverage
  * @param {Annotation} [props.note] - Information about the prescription
  * @param {Dosage} [props.dosageInstruction] - How the medication should be taken
  * @param {BackboneElement} [props.dispenseRequest] - Medication supply authorization
  * @param {BackboneElement} [props.substitution] - Any restrictions on medication substitution
  * @param {Reference} [props.priorPrescription] - An order/prescription that is being replaced
  * @param {Reference} [props.detectedIssue] - Clinical Issue with action
  * @param {Reference} [props.eventHistory] - A list of events of interest in the lifecycle
  */
export function medicationRequest(type: "MedicationRequest", props: MedicationRequest_Props);

export function medicationRequest(props: MedicationRequest_Props);

export function medicationRequest(type: any, props?: any) {
    const mappings = {
        "MedicationRequest": build_MedicationRequest
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "MedicationRequest";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a MedicationStatement resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {Identifier} [props.identifier] - External identifier
  * @param {Reference} [props.basedOn] - Fulfils plan, proposal or order
  * @param {Reference} [props.partOf] - Part of referenced event
  * @param {string} [props.status] - active | completed | entered-in-error | intended | stopped | on-hold | unknown | not-taken
  * @param {CodeableConcept} [props.statusReason] - Reason for current status
  * @param {CodeableConcept} [props.category] - Type of medication usage
  * @param {CodeableConcept|Reference} [props.medication] - What medication was taken
  * @param {Reference} [props.subject] - Who is/was taking  the medication
  * @param {Reference} [props.context] - Encounter / Episode associated with MedicationStatement
  * @param {dateTime|Period} [props.effective] - The date/time or interval when the medication is/was/will be taken
  * @param {dateTime} [props.dateAsserted] - When the statement was asserted?
  * @param {Reference} [props.informationSource] - Person or organization that provided the information about the taking of this medication
  * @param {Reference} [props.derivedFrom] - Additional supporting information
  * @param {CodeableConcept} [props.reasonCode] - Reason for why the medication is being/was taken
  * @param {Reference} [props.reasonReference] - Condition or observation that supports why the medication is being/was taken
  * @param {Annotation} [props.note] - Further information about the statement
  * @param {Dosage} [props.dosage] - Details of how medication is/was taken or should be taken
  */
export function medicationStatement(type: "MedicationStatement", props: MedicationStatement_Props);

export function medicationStatement(props: MedicationStatement_Props);

export function medicationStatement(type: any, props?: any) {
    const mappings = {
        "MedicationStatement": build_MedicationStatement
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "MedicationStatement";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a MedicinalProductDefinition resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {Identifier} [props.identifier] - Business identifier for this product. Could be an MPID
  * @param {CodeableConcept} [props.type] - Regulatory type, e.g. Investigational or Authorized
  * @param {CodeableConcept} [props.domain] - If this medicine applies to human or veterinary uses
  * @param {string} [props.version] - A business identifier relating to a specific version of the product
  * @param {CodeableConcept} [props.status] - The status within the lifecycle of this product record
  * @param {dateTime} [props.statusDate] - The date at which the given status became applicable
  * @param {markdown} [props.description] - General description of this product
  * @param {CodeableConcept} [props.combinedPharmaceuticalDoseForm] - The dose form for a single part product, or combined form of a multiple part product
  * @param {CodeableConcept} [props.route] - The path by which the product is taken into or makes contact with the body
  * @param {markdown} [props.indication] - Description of indication(s) for this product, used when structured indications are not required
  * @param {CodeableConcept} [props.legalStatusOfSupply] - The legal status of supply of the medicinal product as classified by the regulator
  * @param {CodeableConcept} [props.additionalMonitoringIndicator] - Whether the Medicinal Product is subject to additional monitoring for regulatory reasons
  * @param {CodeableConcept} [props.specialMeasures] - Whether the Medicinal Product is subject to special measures for regulatory reasons
  * @param {CodeableConcept} [props.pediatricUseIndicator] - If authorised for use in children
  * @param {CodeableConcept} [props.classification] - Allows the product to be classified by various systems
  * @param {MarketingStatus} [props.marketingStatus] - Marketing status of the medicinal product, in contrast to marketing authorization
  * @param {CodeableConcept} [props.packagedMedicinalProduct] - Package type for the product
  * @param {CodeableConcept} [props.ingredient] - The ingredients of this medicinal product - when not detailed in other resources
  * @param {CodeableReference} [props.impurity] - Any component of the drug product which is not the chemical entity defined as the drug substance, or an excipient in the drug product
  * @param {Reference} [props.attachedDocument] - Additional documentation about the medicinal product
  * @param {Reference} [props.masterFile] - A master file for the medicinal product (e.g. Pharmacovigilance System Master File)
  * @param {BackboneElement} [props.contact] - A product specific contact, person (in a role), or an organization
  * @param {Reference} [props.clinicalTrial] - Clinical trials or studies that this product is involved in
  * @param {Coding} [props.code] - A code that this product is known by, within some formal terminology
  * @param {BackboneElement} [props.name] - The product's name, including full name and possibly coded parts
  * @param {BackboneElement} [props.crossReference] - Reference to another product, e.g. for linking authorised to investigational product
  * @param {BackboneElement} [props.operation] - A manufacturing or administrative process for the medicinal product
  * @param {BackboneElement} [props.characteristic] - Key product features such as "sugar free", "modified release"
  */
export function medicinalProductDefinition(
    type: "MedicinalProductDefinition",
    props: MedicinalProductDefinition_Props
);

export function medicinalProductDefinition(props: MedicinalProductDefinition_Props);

export function medicinalProductDefinition(type: any, props?: any) {
    const mappings = {
        "MedicinalProductDefinition": build_MedicinalProductDefinition
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "MedicinalProductDefinition";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a MolecularSequence resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {Identifier} [props.identifier] - Unique ID for this particular sequence. This is a FHIR-defined id
  * @param {string} [props.type] - aa | dna | rna
  * @param {integer} [props.coordinateSystem] - Base number of coordinate system (0 for 0-based numbering or coordinates, inclusive start, exclusive end, 1 for 1-based numbering, inclusive start, inclusive end)
  * @param {Reference} [props.patient] - Who and/or what this is about
  * @param {Reference} [props.specimen] - Specimen used for sequencing
  * @param {Reference} [props.device] - The method for sequencing
  * @param {Reference} [props.performer] - Who should be responsible for test result
  * @param {Quantity} [props.quantity] - The number of copies of the sequence of interest.  (RNASeq)
  * @param {BackboneElement} [props.referenceSeq] - A sequence used as reference
  * @param {BackboneElement} [props.variant] - Variant in sequence
  * @param {string} [props.observedSeq] - Sequence that was observed
  * @param {BackboneElement} [props.quality] - An set of value as quality of sequence
  * @param {integer} [props.readCoverage] - Average number of reads representing a given nucleotide in the reconstructed sequence
  * @param {BackboneElement} [props.repository] - External repository which contains detailed report related with observedSeq in this resource
  * @param {Reference} [props.pointer] - Pointer to next atomic sequence
  * @param {BackboneElement} [props.structureVariant] - Structural variant
  */
export function molecularSequence(type: "MolecularSequence", props: MolecularSequence_Props);

export function molecularSequence(props: MolecularSequence_Props);

export function molecularSequence(type: any, props?: any) {
    const mappings = {
        "MolecularSequence": build_MolecularSequence
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "MolecularSequence";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a NutritionOrder resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {Identifier} [props.identifier] - Identifiers assigned to this order
  * @param {canonical} [props.instantiatesCanonical] - Instantiates FHIR protocol or definition
  * @param {string} [props.instantiatesUri] - Instantiates external protocol or definition
  * @param {string} [props.instantiates] - Instantiates protocol or definition
  * @param {string} [props.status] - draft | active | on-hold | revoked | completed | entered-in-error | unknown
  * @param {string} [props.intent] - proposal | plan | directive | order | original-order | reflex-order | filler-order | instance-order | option
  * @param {Reference} [props.patient] - The person who requires the diet, formula or nutritional supplement
  * @param {Reference} [props.encounter] - The encounter associated with this nutrition order
  * @param {dateTime} [props.dateTime] - Date and time the nutrition order was requested
  * @param {Reference} [props.orderer] - Who ordered the diet, formula or nutritional supplement
  * @param {Reference} [props.allergyIntolerance] - List of the patient's food and nutrition-related allergies and intolerances
  * @param {CodeableConcept} [props.foodPreferenceModifier] - Order-specific modifier about the type of food that should be given
  * @param {CodeableConcept} [props.excludeFoodModifier] - Order-specific modifier about the type of food that should not be given
  * @param {BackboneElement} [props.oralDiet] - Oral diet components
  * @param {BackboneElement} [props.supplement] - Supplement components
  * @param {BackboneElement} [props.enteralFormula] - Enteral formula components
  * @param {Annotation} [props.note] - Comments
  */
export function nutritionOrder(type: "NutritionOrder", props: NutritionOrder_Props);

export function nutritionOrder(props: NutritionOrder_Props);

export function nutritionOrder(type: any, props?: any) {
    const mappings = {
        "NutritionOrder": build_NutritionOrder
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "NutritionOrder";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a NutritionProduct resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {string} [props.status] - active | inactive | entered-in-error
  * @param {CodeableConcept} [props.category] - A category or class of the nutrition product (halal, kosher, gluten free, vegan, etc)
  * @param {CodeableConcept} [props.code] - A code designating a specific type of nutritional product
  * @param {Reference} [props.manufacturer] - Manufacturer, representative or officially responsible for the product
  * @param {BackboneElement} [props.nutrient] - The product's nutritional information expressed by the nutrients
  * @param {BackboneElement} [props.ingredient] - Ingredients contained in this product
  * @param {CodeableReference} [props.knownAllergen] - Known or suspected allergens that are a part of this product
  * @param {BackboneElement} [props.productCharacteristic] - Specifies descriptive properties of the nutrition product
  * @param {BackboneElement} [props.instance] - One or several physical instances or occurrences of the nutrition product
  * @param {Annotation} [props.note] - Comments made about the product
  */
export function nutritionProduct(type: "NutritionProduct", props: NutritionProduct_Props);

export function nutritionProduct(props: NutritionProduct_Props);

export function nutritionProduct(type: any, props?: any) {
    const mappings = {
        "NutritionProduct": build_NutritionProduct
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "NutritionProduct";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a Observation resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {Identifier} [props.identifier] - Business Identifier for observation
  * @param {Reference} [props.basedOn] - Fulfills plan, proposal or order
  * @param {Reference} [props.partOf] - Part of referenced event
  * @param {string} [props.status] - registered | preliminary | final | amended +
  * @param {CodeableConcept} [props.category] - Classification of  type of observation
  * @param {CodeableConcept} [props.code] - Type of observation (code / type)
  * @param {Reference} [props.subject] - Who and/or what the observation is about
  * @param {Reference} [props.focus] - What the observation is about, when it is not about the subject of record
  * @param {Reference} [props.encounter] - Healthcare event during which this observation is made
  * @param {dateTime|Period|Timing|instant} [props.effective] - Clinically relevant time/time-period for observation
  * @param {instant} [props.issued] - Date/Time this version was made available
  * @param {Reference} [props.performer] - Who is responsible for the observation
  * @param {Quantity|CodeableConcept|string|boolean|integer|Range|Ratio|SampledData|time|dateTime|Period} [props.value] - Actual result
  * @param {CodeableConcept} [props.dataAbsentReason] - Why the result is missing
  * @param {CodeableConcept} [props.interpretation] - High, low, normal, etc.
  * @param {Annotation} [props.note] - Comments about the observation
  * @param {CodeableConcept} [props.bodySite] - Observed body part
  * @param {CodeableConcept} [props.method] - How it was done
  * @param {Reference} [props.specimen] - Specimen used for this observation
  * @param {Reference} [props.device] - (Measurement) Device
  * @param {BackboneElement} [props.referenceRange] - Provides guide for interpretation
  * @param {Reference} [props.hasMember] - Related resource that belongs to the Observation group
  * @param {Reference} [props.derivedFrom] - Related measurements the observation is made from
  * @param {BackboneElement} [props.component] - Component results
  */
export function observation(type: "Observation", props: Observation_Props);

export function observation(props: Observation_Props);

export function observation(type: any, props?: any) {
    const mappings = {
        "Observation": build_Observation
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "Observation";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a ObservationDefinition resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {CodeableConcept} [props.category] - Category of observation
  * @param {CodeableConcept} [props.code] - Type of observation (code / type)
  * @param {Identifier} [props.identifier] - Business identifier for this ObservationDefinition instance
  * @param {string} [props.permittedDataType] - Quantity | CodeableConcept | string | boolean | integer | Range | Ratio | SampledData | time | dateTime | Period
  * @param {boolean} [props.multipleResultsAllowed] - Multiple results allowed
  * @param {CodeableConcept} [props.method] - Method used to produce the observation
  * @param {string} [props.preferredReportName] - Preferred report name
  * @param {BackboneElement} [props.quantitativeDetails] - Characteristics of quantitative results
  * @param {BackboneElement} [props.qualifiedInterval] - Qualified range for continuous and ordinal observation results
  * @param {Reference} [props.validCodedValueSet] - Value set of valid coded values for the observations conforming to this ObservationDefinition
  * @param {Reference} [props.normalCodedValueSet] - Value set of normal coded values for the observations conforming to this ObservationDefinition
  * @param {Reference} [props.abnormalCodedValueSet] - Value set of abnormal coded values for the observations conforming to this ObservationDefinition
  * @param {Reference} [props.criticalCodedValueSet] - Value set of critical coded values for the observations conforming to this ObservationDefinition
  */
export function observationDefinition(type: "ObservationDefinition", props: ObservationDefinition_Props);

export function observationDefinition(props: ObservationDefinition_Props);

export function observationDefinition(type: any, props?: any) {
    const mappings = {
        "ObservationDefinition": build_ObservationDefinition
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "ObservationDefinition";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a Organization resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {Identifier} [props.identifier] - Identifies this organization  across multiple systems
  * @param {boolean} [props.active] - Whether the organization's record is still in active use
  * @param {CodeableConcept} [props.type] - Kind of organization
  * @param {string} [props.name] - Name used for the organization
  * @param {string} [props.alias] - A list of alternate names that the organization is known as, or was known as in the past
  * @param {ContactPoint} [props.telecom] - A contact detail for the organization
  * @param {Address} [props.address] - An address for the organization
  * @param {Reference} [props.partOf] - The organization of which this organization forms a part
  * @param {BackboneElement} [props.contact] - Contact for the organization for a certain purpose
  * @param {Reference} [props.endpoint] - Technical endpoints providing access to services operated for the organization
  */
export function organization(type: "Organization", props: Organization_Props);

export function organization(props: Organization_Props);

export function organization(type: any, props?: any) {
    const mappings = {
        "Organization": build_Organization
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "Organization";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a OrganizationAffiliation resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {Identifier} [props.identifier] - Business identifiers that are specific to this role
  * @param {boolean} [props.active] - Whether this organization affiliation record is in active use
  * @param {Period} [props.period] - The period during which the participatingOrganization is affiliated with the primary organization
  * @param {Reference} [props.organization] - Organization where the role is available
  * @param {Reference} [props.participatingOrganization] - Organization that provides/performs the role (e.g. providing services or is a member of)
  * @param {Reference} [props.network] - Health insurance provider network in which the participatingOrganization provides the role's services (if defined) at the indicated locations (if defined)
  * @param {CodeableConcept} [props.code] - Definition of the role the participatingOrganization plays
  * @param {CodeableConcept} [props.specialty] - Specific specialty of the participatingOrganization in the context of the role
  * @param {Reference} [props.location] - The location(s) at which the role occurs
  * @param {Reference} [props.healthcareService] - Healthcare services provided through the role
  * @param {ContactPoint} [props.telecom] - Contact details at the participatingOrganization relevant to this Affiliation
  * @param {Reference} [props.endpoint] - Technical endpoints providing access to services operated for this role
  */
export function organizationAffiliation(type: "OrganizationAffiliation", props: OrganizationAffiliation_Props);

export function organizationAffiliation(props: OrganizationAffiliation_Props);

export function organizationAffiliation(type: any, props?: any) {
    const mappings = {
        "OrganizationAffiliation": build_OrganizationAffiliation
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "OrganizationAffiliation";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a PackagedProductDefinition resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {Identifier} [props.identifier] - A unique identifier for this package as whole
  * @param {string} [props.name] - A name for this package. Typically as listed in a drug formulary, catalogue, inventory etc
  * @param {CodeableConcept} [props.type] - A high level category e.g. medicinal product, raw material, shipping container etc
  * @param {Reference} [props.packageFor] - The product that this is a pack for
  * @param {CodeableConcept} [props.status] - The status within the lifecycle of this item. High level - not intended to duplicate details elsewhere e.g. legal status, or authorization/marketing status
  * @param {dateTime} [props.statusDate] - The date at which the given status became applicable
  * @param {Quantity} [props.containedItemQuantity] - A total of the complete count of contained items of a particular type/form, independent of sub-packaging or organization. This can be considered as the pack size
  * @param {markdown} [props.description] - Textual description. Note that this is not the name of the package or product
  * @param {BackboneElement} [props.legalStatusOfSupply] - The legal status of supply of the packaged item as classified by the regulator
  * @param {MarketingStatus} [props.marketingStatus] - Allows specifying that an item is on the market for sale, or that it is not available, and the dates and locations associated
  * @param {CodeableConcept} [props.characteristic] - Allows the key features to be recorded, such as "hospital pack", "nurse prescribable"
  * @param {boolean} [props.copackagedIndicator] - If the drug product is supplied with another item such as a diluent or adjuvant
  * @param {Reference} [props.manufacturer] - Manufacturer of this package type (multiple means these are all possible manufacturers)
  * @param {BackboneElement} [props.package] - A packaging item, as a container for medically related items, possibly with other packaging items within, or a packaging component, such as bottle cap
  */
export function packagedProductDefinition(type: "PackagedProductDefinition", props: PackagedProductDefinition_Props);

export function packagedProductDefinition(props: PackagedProductDefinition_Props);

export function packagedProductDefinition(type: any, props?: any) {
    const mappings = {
        "PackagedProductDefinition": build_PackagedProductDefinition
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "PackagedProductDefinition";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a Patient resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {Identifier} [props.identifier] - An identifier for this patient
  * @param {boolean} [props.active] - Whether this patient's record is in active use
  * @param {HumanName} [props.name] - A name associated with the patient
  * @param {ContactPoint} [props.telecom] - A contact detail for the individual
  * @param {string} [props.gender] - male | female | other | unknown
  * @param {date} [props.birthDate] - The date of birth for the individual
  * @param {boolean|dateTime} [props.deceased] - Indicates if the individual is deceased or not
  * @param {Address} [props.address] - An address for the individual
  * @param {CodeableConcept} [props.maritalStatus] - Marital (civil) status of a patient
  * @param {boolean|integer} [props.multipleBirth] - Whether patient is part of a multiple birth
  * @param {Attachment} [props.photo] - Image of the patient
  * @param {BackboneElement} [props.contact] - A contact party (e.g. guardian, partner, friend) for the patient
  * @param {BackboneElement} [props.communication] - A language which may be used to communicate with the patient about his or her health
  * @param {Reference} [props.generalPractitioner] - Patient's nominated primary care provider
  * @param {Reference} [props.managingOrganization] - Organization that is the custodian of the patient record
  * @param {BackboneElement} [props.link] - Link to another patient resource that concerns the same actual person
  */
export function patient(type: "Patient", props: Patient_Props);

export function patient(props: Patient_Props);

export function patient(type: any, props?: any) {
    const mappings = {
        "Patient": build_Patient
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "Patient";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a PaymentNotice resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {Identifier} [props.identifier] - Business Identifier for the payment noctice
  * @param {string} [props.status] - active | cancelled | draft | entered-in-error
  * @param {Reference} [props.request] - Request reference
  * @param {Reference} [props.response] - Response reference
  * @param {dateTime} [props.created] - Creation date
  * @param {Reference} [props.provider] - Responsible practitioner
  * @param {Reference} [props.payment] - Payment reference
  * @param {date} [props.paymentDate] - Payment or clearing date
  * @param {Reference} [props.payee] - Party being paid
  * @param {Reference} [props.recipient] - Party being notified
  * @param {Money} [props.amount] - Monetary amount of the payment
  * @param {CodeableConcept} [props.paymentStatus] - Issued or cleared Status of the payment
  */
export function paymentNotice(type: "PaymentNotice", props: PaymentNotice_Props);

export function paymentNotice(props: PaymentNotice_Props);

export function paymentNotice(type: any, props?: any) {
    const mappings = {
        "PaymentNotice": build_PaymentNotice
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "PaymentNotice";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a PaymentReconciliation resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {Identifier} [props.identifier] - Business Identifier for a payment reconciliation
  * @param {string} [props.status] - active | cancelled | draft | entered-in-error
  * @param {Period} [props.period] - Period covered
  * @param {dateTime} [props.created] - Creation date
  * @param {Reference} [props.paymentIssuer] - Party generating payment
  * @param {Reference} [props.request] - Reference to requesting resource
  * @param {Reference} [props.requestor] - Responsible practitioner
  * @param {string} [props.outcome] - queued | complete | error | partial
  * @param {string} [props.disposition] - Disposition message
  * @param {date} [props.paymentDate] - When payment issued
  * @param {Money} [props.paymentAmount] - Total amount of Payment
  * @param {Identifier} [props.paymentIdentifier] - Business identifier for the payment
  * @param {BackboneElement} [props.detail] - Settlement particulars
  * @param {CodeableConcept} [props.formCode] - Printed form identifier
  * @param {BackboneElement} [props.processNote] - Note concerning processing
  */
export function paymentReconciliation(type: "PaymentReconciliation", props: PaymentReconciliation_Props);

export function paymentReconciliation(props: PaymentReconciliation_Props);

export function paymentReconciliation(type: any, props?: any) {
    const mappings = {
        "PaymentReconciliation": build_PaymentReconciliation
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "PaymentReconciliation";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a Person resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {Identifier} [props.identifier] - A human identifier for this person
  * @param {HumanName} [props.name] - A name associated with the person
  * @param {ContactPoint} [props.telecom] - A contact detail for the person
  * @param {string} [props.gender] - male | female | other | unknown
  * @param {date} [props.birthDate] - The date on which the person was born
  * @param {Address} [props.address] - One or more addresses for the person
  * @param {Attachment} [props.photo] - Image of the person
  * @param {Reference} [props.managingOrganization] - The organization that is the custodian of the person record
  * @param {boolean} [props.active] - This person's record is in active use
  * @param {BackboneElement} [props.link] - Link to a resource that concerns the same actual person
  */
export function person(type: "Person", props: Person_Props);

export function person(props: Person_Props);

export function person(type: any, props?: any) {
    const mappings = {
        "Person": build_Person
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "Person";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a PlanDefinition resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {string} [props.url] - Canonical identifier for this plan definition, represented as a URI (globally unique)
  * @param {Identifier} [props.identifier] - Additional identifier for the plan definition
  * @param {string} [props.version] - Business version of the plan definition
  * @param {string} [props.name] - Name for this plan definition (computer friendly)
  * @param {string} [props.title] - Name for this plan definition (human friendly)
  * @param {string} [props.subtitle] - Subordinate title of the plan definition
  * @param {CodeableConcept} [props.type] - order-set | clinical-protocol | eca-rule | workflow-definition
  * @param {string} [props.status] - draft | active | retired | unknown
  * @param {boolean} [props.experimental] - For testing purposes, not real usage
  * @param {CodeableConcept|Reference|canonical} [props.subject] - Type of individual the plan definition is focused on
  * @param {dateTime} [props.date] - Date last changed
  * @param {string} [props.publisher] - Name of the publisher (organization or individual)
  * @param {ContactDetail} [props.contact] - Contact details for the publisher
  * @param {markdown} [props.description] - Natural language description of the plan definition
  * @param {UsageContext} [props.useContext] - The context that the content is intended to support
  * @param {CodeableConcept} [props.jurisdiction] - Intended jurisdiction for plan definition (if applicable)
  * @param {markdown} [props.purpose] - Why this plan definition is defined
  * @param {string} [props.usage] - Describes the clinical usage of the plan
  * @param {markdown} [props.copyright] - Use and/or publishing restrictions
  * @param {date} [props.approvalDate] - When the plan definition was approved by publisher
  * @param {date} [props.lastReviewDate] - When the plan definition was last reviewed
  * @param {Period} [props.effectivePeriod] - When the plan definition is expected to be used
  * @param {CodeableConcept} [props.topic] - E.g. Education, Treatment, Assessment
  * @param {ContactDetail} [props.author] - Who authored the content
  * @param {ContactDetail} [props.editor] - Who edited the content
  * @param {ContactDetail} [props.reviewer] - Who reviewed the content
  * @param {ContactDetail} [props.endorser] - Who endorsed the content
  * @param {RelatedArtifact} [props.relatedArtifact] - Additional documentation, citations
  * @param {canonical} [props.library] - Logic used by the plan definition
  * @param {BackboneElement} [props.goal] - What the plan is trying to accomplish
  * @param {BackboneElement} [props.action] - Action defined by the plan
  */
export function planDefinition(type: "PlanDefinition", props: PlanDefinition_Props);

export function planDefinition(props: PlanDefinition_Props);

export function planDefinition(type: any, props?: any) {
    const mappings = {
        "PlanDefinition": build_PlanDefinition
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "PlanDefinition";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a Practitioner resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {Identifier} [props.identifier] - An identifier for the person as this agent
  * @param {boolean} [props.active] - Whether this practitioner's record is in active use
  * @param {HumanName} [props.name] - The name(s) associated with the practitioner
  * @param {ContactPoint} [props.telecom] - A contact detail for the practitioner (that apply to all roles)
  * @param {Address} [props.address] - Address(es) of the practitioner that are not role specific (typically home address)
  * @param {string} [props.gender] - male | female | other | unknown
  * @param {date} [props.birthDate] - The date  on which the practitioner was born
  * @param {Attachment} [props.photo] - Image of the person
  * @param {BackboneElement} [props.qualification] - Certification, licenses, or training pertaining to the provision of care
  * @param {CodeableConcept} [props.communication] - A language the practitioner can use in patient communication
  */
export function practitioner(type: "Practitioner", props: Practitioner_Props);

export function practitioner(props: Practitioner_Props);

export function practitioner(type: any, props?: any) {
    const mappings = {
        "Practitioner": build_Practitioner
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "Practitioner";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a PractitionerRole resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {Identifier} [props.identifier] - Business Identifiers that are specific to a role/location
  * @param {boolean} [props.active] - Whether this practitioner role record is in active use
  * @param {Period} [props.period] - The period during which the practitioner is authorized to perform in these role(s)
  * @param {Reference} [props.practitioner] - Practitioner that is able to provide the defined services for the organization
  * @param {Reference} [props.organization] - Organization where the roles are available
  * @param {CodeableConcept} [props.code] - Roles which this practitioner may perform
  * @param {CodeableConcept} [props.specialty] - Specific specialty of the practitioner
  * @param {Reference} [props.location] - The location(s) at which this practitioner provides care
  * @param {Reference} [props.healthcareService] - The list of healthcare services that this worker provides for this role's Organization/Location(s)
  * @param {ContactPoint} [props.telecom] - Contact details that are specific to the role/location/service
  * @param {BackboneElement} [props.availableTime] - Times the Service Site is available
  * @param {BackboneElement} [props.notAvailable] - Not available during this time due to provided reason
  * @param {string} [props.availabilityExceptions] - Description of availability exceptions
  * @param {Reference} [props.endpoint] - Technical endpoints providing access to services operated for the practitioner with this role
  */
export function practitionerRole(type: "PractitionerRole", props: PractitionerRole_Props);

export function practitionerRole(props: PractitionerRole_Props);

export function practitionerRole(type: any, props?: any) {
    const mappings = {
        "PractitionerRole": build_PractitionerRole
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "PractitionerRole";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a Procedure resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {Identifier} [props.identifier] - External Identifiers for this procedure
  * @param {canonical} [props.instantiatesCanonical] - Instantiates FHIR protocol or definition
  * @param {string} [props.instantiatesUri] - Instantiates external protocol or definition
  * @param {Reference} [props.basedOn] - A request for this procedure
  * @param {Reference} [props.partOf] - Part of referenced event
  * @param {string} [props.status] - preparation | in-progress | not-done | on-hold | stopped | completed | entered-in-error | unknown
  * @param {CodeableConcept} [props.statusReason] - Reason for current status
  * @param {CodeableConcept} [props.category] - Classification of the procedure
  * @param {CodeableConcept} [props.code] - Identification of the procedure
  * @param {Reference} [props.subject] - Who the procedure was performed on
  * @param {Reference} [props.encounter] - Encounter created as part of
  * @param {dateTime|Period|string|Age|Range} [props.performed] - When the procedure was performed
  * @param {Reference} [props.recorder] - Who recorded the procedure
  * @param {Reference} [props.asserter] - Person who asserts this procedure
  * @param {BackboneElement} [props.performer] - The people who performed the procedure
  * @param {Reference} [props.location] - Where the procedure happened
  * @param {CodeableConcept} [props.reasonCode] - Coded reason procedure performed
  * @param {Reference} [props.reasonReference] - The justification that the procedure was performed
  * @param {CodeableConcept} [props.bodySite] - Target body sites
  * @param {CodeableConcept} [props.outcome] - The result of procedure
  * @param {Reference} [props.report] - Any report resulting from the procedure
  * @param {CodeableConcept} [props.complication] - Complication following the procedure
  * @param {Reference} [props.complicationDetail] - A condition that is a result of the procedure
  * @param {CodeableConcept} [props.followUp] - Instructions for follow up
  * @param {Annotation} [props.note] - Additional information about the procedure
  * @param {BackboneElement} [props.focalDevice] - Manipulated, implanted, or removed device
  * @param {Reference} [props.usedReference] - Items used during procedure
  * @param {CodeableConcept} [props.usedCode] - Coded items used during the procedure
  */
export function procedure(type: "Procedure", props: Procedure_Props);

export function procedure(props: Procedure_Props);

export function procedure(type: any, props?: any) {
    const mappings = {
        "Procedure": build_Procedure
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "Procedure";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a Questionnaire resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {string} [props.url] - Canonical identifier for this questionnaire, represented as a URI (globally unique)
  * @param {Identifier} [props.identifier] - Additional identifier for the questionnaire
  * @param {string} [props.version] - Business version of the questionnaire
  * @param {string} [props.name] - Name for this questionnaire (computer friendly)
  * @param {string} [props.title] - Name for this questionnaire (human friendly)
  * @param {canonical} [props.derivedFrom] - Instantiates protocol or definition
  * @param {string} [props.status] - draft | active | retired | unknown
  * @param {boolean} [props.experimental] - For testing purposes, not real usage
  * @param {string} [props.subjectType] - Resource that can be subject of QuestionnaireResponse
  * @param {dateTime} [props.date] - Date last changed
  * @param {string} [props.publisher] - Name of the publisher (organization or individual)
  * @param {ContactDetail} [props.contact] - Contact details for the publisher
  * @param {markdown} [props.description] - Natural language description of the questionnaire
  * @param {UsageContext} [props.useContext] - The context that the content is intended to support
  * @param {CodeableConcept} [props.jurisdiction] - Intended jurisdiction for questionnaire (if applicable)
  * @param {markdown} [props.purpose] - Why this questionnaire is defined
  * @param {markdown} [props.copyright] - Use and/or publishing restrictions
  * @param {date} [props.approvalDate] - When the questionnaire was approved by publisher
  * @param {date} [props.lastReviewDate] - When the questionnaire was last reviewed
  * @param {Period} [props.effectivePeriod] - When the questionnaire is expected to be used
  * @param {Coding} [props.code] - Concept that represents the overall questionnaire
  * @param {BackboneElement} [props.item] - Questions and sections within the Questionnaire
  */
export function questionnaire(type: "Questionnaire", props: Questionnaire_Props);

export function questionnaire(props: Questionnaire_Props);

export function questionnaire(type: any, props?: any) {
    const mappings = {
        "Questionnaire": build_Questionnaire
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "Questionnaire";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a QuestionnaireResponse resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {Identifier} [props.identifier] - Unique id for this set of answers
  * @param {Reference} [props.basedOn] - Request fulfilled by this QuestionnaireResponse
  * @param {Reference} [props.partOf] - Part of this action
  * @param {canonical} [props.questionnaire] - Form being answered
  * @param {string} [props.status] - in-progress | completed | amended | entered-in-error | stopped
  * @param {Reference} [props.subject] - The subject of the questions
  * @param {Reference} [props.encounter] - Encounter created as part of
  * @param {dateTime} [props.authored] - Date the answers were gathered
  * @param {Reference} [props.author] - Person who received and recorded the answers
  * @param {Reference} [props.source] - The person who answered the questions
  * @param {BackboneElement} [props.item] - Groups and questions
  */
export function questionnaireResponse(type: "QuestionnaireResponse", props: QuestionnaireResponse_Props);

export function questionnaireResponse(props: QuestionnaireResponse_Props);

export function questionnaireResponse(type: any, props?: any) {
    const mappings = {
        "QuestionnaireResponse": build_QuestionnaireResponse
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "QuestionnaireResponse";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a RegulatedAuthorization resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {Identifier} [props.identifier] - Business identifier for the authorization, typically assigned by the authorizing body
  * @param {Reference} [props.subject] - The product type, treatment, facility or activity that is being authorized
  * @param {CodeableConcept} [props.type] - Overall type of this authorization, for example drug marketing approval, orphan drug designation
  * @param {markdown} [props.description] - General textual supporting information
  * @param {CodeableConcept} [props.region] - The territory in which the authorization has been granted
  * @param {CodeableConcept} [props.status] - The status that is authorised e.g. approved. Intermediate states can be tracked with cases and applications
  * @param {dateTime} [props.statusDate] - The date at which the current status was assigned
  * @param {Period} [props.validityPeriod] - The time period in which the regulatory approval etc. is in effect, e.g. a Marketing Authorization includes the date of authorization and/or expiration date
  * @param {CodeableReference} [props.indication] - Condition for which the use of the regulated product applies
  * @param {CodeableConcept} [props.intendedUse] - The intended use of the product, e.g. prevention, treatment
  * @param {CodeableConcept} [props.basis] - The legal/regulatory framework or reasons under which this authorization is granted
  * @param {Reference} [props.holder] - The organization that has been granted this authorization, by the regulator
  * @param {Reference} [props.regulator] - The regulatory authority or authorizing body granting the authorization
  * @param {BackboneElement} [props.case] - The case or regulatory procedure for granting or amending a regulated authorization. Note: This area is subject to ongoing review and the workgroup is seeking implementer feedback on its use (see link at bottom of page)
  */
export function regulatedAuthorization(type: "RegulatedAuthorization", props: RegulatedAuthorization_Props);

export function regulatedAuthorization(props: RegulatedAuthorization_Props);

export function regulatedAuthorization(type: any, props?: any) {
    const mappings = {
        "RegulatedAuthorization": build_RegulatedAuthorization
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "RegulatedAuthorization";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a RelatedPerson resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {Identifier} [props.identifier] - A human identifier for this person
  * @param {boolean} [props.active] - Whether this related person's record is in active use
  * @param {Reference} [props.patient] - The patient this person is related to
  * @param {CodeableConcept} [props.relationship] - The nature of the relationship
  * @param {HumanName} [props.name] - A name associated with the person
  * @param {ContactPoint} [props.telecom] - A contact detail for the person
  * @param {string} [props.gender] - male | female | other | unknown
  * @param {date} [props.birthDate] - The date on which the related person was born
  * @param {Address} [props.address] - Address where the related person can be contacted or visited
  * @param {Attachment} [props.photo] - Image of the person
  * @param {Period} [props.period] - Period of time that this relationship is considered valid
  * @param {BackboneElement} [props.communication] - A language which may be used to communicate with about the patient's health
  */
export function relatedPerson(type: "RelatedPerson", props: RelatedPerson_Props);

export function relatedPerson(props: RelatedPerson_Props);

export function relatedPerson(type: any, props?: any) {
    const mappings = {
        "RelatedPerson": build_RelatedPerson
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "RelatedPerson";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a RequestGroup resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {Identifier} [props.identifier] - Business identifier
  * @param {canonical} [props.instantiatesCanonical] - Instantiates FHIR protocol or definition
  * @param {string} [props.instantiatesUri] - Instantiates external protocol or definition
  * @param {Reference} [props.basedOn] - Fulfills plan, proposal, or order
  * @param {Reference} [props.replaces] - Request(s) replaced by this request
  * @param {Identifier} [props.groupIdentifier] - Composite request this is part of
  * @param {string} [props.status] - draft | active | on-hold | revoked | completed | entered-in-error | unknown
  * @param {string} [props.intent] - proposal | plan | directive | order | original-order | reflex-order | filler-order | instance-order | option
  * @param {string} [props.priority] - routine | urgent | asap | stat
  * @param {CodeableConcept} [props.code] - What's being requested/ordered
  * @param {Reference} [props.subject] - Who the request group is about
  * @param {Reference} [props.encounter] - Created as part of
  * @param {dateTime} [props.authoredOn] - When the request group was authored
  * @param {Reference} [props.author] - Device or practitioner that authored the request group
  * @param {CodeableConcept} [props.reasonCode] - Why the request group is needed
  * @param {Reference} [props.reasonReference] - Why the request group is needed
  * @param {Annotation} [props.note] - Additional notes about the response
  * @param {BackboneElement} [props.action] - Proposed actions, if any
  */
export function requestGroup(type: "RequestGroup", props: RequestGroup_Props);

export function requestGroup(props: RequestGroup_Props);

export function requestGroup(type: any, props?: any) {
    const mappings = {
        "RequestGroup": build_RequestGroup
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "RequestGroup";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a ResearchDefinition resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {string} [props.url] - Canonical identifier for this research definition, represented as a URI (globally unique)
  * @param {Identifier} [props.identifier] - Additional identifier for the research definition
  * @param {string} [props.version] - Business version of the research definition
  * @param {string} [props.name] - Name for this research definition (computer friendly)
  * @param {string} [props.title] - Name for this research definition (human friendly)
  * @param {string} [props.shortTitle] - Title for use in informal contexts
  * @param {string} [props.subtitle] - Subordinate title of the ResearchDefinition
  * @param {string} [props.status] - draft | active | retired | unknown
  * @param {boolean} [props.experimental] - For testing purposes, not real usage
  * @param {CodeableConcept|Reference} [props.subject] - E.g. Patient, Practitioner, RelatedPerson, Organization, Location, Device
  * @param {dateTime} [props.date] - Date last changed
  * @param {string} [props.publisher] - Name of the publisher (organization or individual)
  * @param {ContactDetail} [props.contact] - Contact details for the publisher
  * @param {markdown} [props.description] - Natural language description of the research definition
  * @param {string} [props.comment] - Used for footnotes or explanatory notes
  * @param {UsageContext} [props.useContext] - The context that the content is intended to support
  * @param {CodeableConcept} [props.jurisdiction] - Intended jurisdiction for research definition (if applicable)
  * @param {markdown} [props.purpose] - Why this research definition is defined
  * @param {string} [props.usage] - Describes the clinical usage of the ResearchDefinition
  * @param {markdown} [props.copyright] - Use and/or publishing restrictions
  * @param {date} [props.approvalDate] - When the research definition was approved by publisher
  * @param {date} [props.lastReviewDate] - When the research definition was last reviewed
  * @param {Period} [props.effectivePeriod] - When the research definition is expected to be used
  * @param {CodeableConcept} [props.topic] - The category of the ResearchDefinition, such as Education, Treatment, Assessment, etc.
  * @param {ContactDetail} [props.author] - Who authored the content
  * @param {ContactDetail} [props.editor] - Who edited the content
  * @param {ContactDetail} [props.reviewer] - Who reviewed the content
  * @param {ContactDetail} [props.endorser] - Who endorsed the content
  * @param {RelatedArtifact} [props.relatedArtifact] - Additional documentation, citations, etc.
  * @param {canonical} [props.library] - Logic used by the ResearchDefinition
  * @param {Reference} [props.population] - What population?
  * @param {Reference} [props.exposure] - What exposure?
  * @param {Reference} [props.exposureAlternative] - What alternative exposure state?
  * @param {Reference} [props.outcome] - What outcome?
  */
export function researchDefinition(type: "ResearchDefinition", props: ResearchDefinition_Props);

export function researchDefinition(props: ResearchDefinition_Props);

export function researchDefinition(type: any, props?: any) {
    const mappings = {
        "ResearchDefinition": build_ResearchDefinition
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "ResearchDefinition";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a ResearchElementDefinition resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {string} [props.url] - Canonical identifier for this research element definition, represented as a URI (globally unique)
  * @param {Identifier} [props.identifier] - Additional identifier for the research element definition
  * @param {string} [props.version] - Business version of the research element definition
  * @param {string} [props.name] - Name for this research element definition (computer friendly)
  * @param {string} [props.title] - Name for this research element definition (human friendly)
  * @param {string} [props.shortTitle] - Title for use in informal contexts
  * @param {string} [props.subtitle] - Subordinate title of the ResearchElementDefinition
  * @param {string} [props.status] - draft | active | retired | unknown
  * @param {boolean} [props.experimental] - For testing purposes, not real usage
  * @param {CodeableConcept|Reference} [props.subject] - E.g. Patient, Practitioner, RelatedPerson, Organization, Location, Device
  * @param {dateTime} [props.date] - Date last changed
  * @param {string} [props.publisher] - Name of the publisher (organization or individual)
  * @param {ContactDetail} [props.contact] - Contact details for the publisher
  * @param {markdown} [props.description] - Natural language description of the research element definition
  * @param {string} [props.comment] - Used for footnotes or explanatory notes
  * @param {UsageContext} [props.useContext] - The context that the content is intended to support
  * @param {CodeableConcept} [props.jurisdiction] - Intended jurisdiction for research element definition (if applicable)
  * @param {markdown} [props.purpose] - Why this research element definition is defined
  * @param {string} [props.usage] - Describes the clinical usage of the ResearchElementDefinition
  * @param {markdown} [props.copyright] - Use and/or publishing restrictions
  * @param {date} [props.approvalDate] - When the research element definition was approved by publisher
  * @param {date} [props.lastReviewDate] - When the research element definition was last reviewed
  * @param {Period} [props.effectivePeriod] - When the research element definition is expected to be used
  * @param {CodeableConcept} [props.topic] - The category of the ResearchElementDefinition, such as Education, Treatment, Assessment, etc.
  * @param {ContactDetail} [props.author] - Who authored the content
  * @param {ContactDetail} [props.editor] - Who edited the content
  * @param {ContactDetail} [props.reviewer] - Who reviewed the content
  * @param {ContactDetail} [props.endorser] - Who endorsed the content
  * @param {RelatedArtifact} [props.relatedArtifact] - Additional documentation, citations, etc.
  * @param {canonical} [props.library] - Logic used by the ResearchElementDefinition
  * @param {string} [props.type] - population | exposure | outcome
  * @param {string} [props.variableType] - dichotomous | continuous | descriptive
  * @param {BackboneElement} [props.characteristic] - What defines the members of the research element
  */
export function researchElementDefinition(type: "ResearchElementDefinition", props: ResearchElementDefinition_Props);

export function researchElementDefinition(props: ResearchElementDefinition_Props);

export function researchElementDefinition(type: any, props?: any) {
    const mappings = {
        "ResearchElementDefinition": build_ResearchElementDefinition
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "ResearchElementDefinition";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a ResearchStudy resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {Identifier} [props.identifier] - Business Identifier for study
  * @param {string} [props.title] - Name for this study
  * @param {Reference} [props.protocol] - Steps followed in executing study
  * @param {Reference} [props.partOf] - Part of larger study
  * @param {string} [props.status] - active | administratively-completed | approved | closed-to-accrual | closed-to-accrual-and-intervention | completed | disapproved | in-review | temporarily-closed-to-accrual | temporarily-closed-to-accrual-and-intervention | withdrawn
  * @param {CodeableConcept} [props.primaryPurposeType] - treatment | prevention | diagnostic | supportive-care | screening | health-services-research | basic-science | device-feasibility
  * @param {CodeableConcept} [props.phase] - n-a | early-phase-1 | phase-1 | phase-1-phase-2 | phase-2 | phase-2-phase-3 | phase-3 | phase-4
  * @param {CodeableConcept} [props.category] - Classifications for the study
  * @param {CodeableConcept} [props.focus] - Drugs, devices, etc. under study
  * @param {CodeableConcept} [props.condition] - Condition being studied
  * @param {ContactDetail} [props.contact] - Contact details for the study
  * @param {RelatedArtifact} [props.relatedArtifact] - References and dependencies
  * @param {CodeableConcept} [props.keyword] - Used to search for the study
  * @param {CodeableConcept} [props.location] - Geographic region(s) for study
  * @param {markdown} [props.description] - What this is study doing
  * @param {Reference} [props.enrollment] - Inclusion & exclusion criteria
  * @param {Period} [props.period] - When the study began and ended
  * @param {Reference} [props.sponsor] - Organization that initiates and is legally responsible for the study
  * @param {Reference} [props.principalInvestigator] - Researcher who oversees multiple aspects of the study
  * @param {Reference} [props.site] - Facility where study activities are conducted
  * @param {CodeableConcept} [props.reasonStopped] - accrual-goal-met | closed-due-to-toxicity | closed-due-to-lack-of-study-progress | temporarily-closed-per-study-design
  * @param {Annotation} [props.note] - Comments made about the study
  * @param {BackboneElement} [props.arm] - Defined path through the study for a subject
  * @param {BackboneElement} [props.objective] - A goal for the study
  */
export function researchStudy(type: "ResearchStudy", props: ResearchStudy_Props);

export function researchStudy(props: ResearchStudy_Props);

export function researchStudy(type: any, props?: any) {
    const mappings = {
        "ResearchStudy": build_ResearchStudy
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "ResearchStudy";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a ResearchSubject resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {Identifier} [props.identifier] - Business Identifier for research subject in a study
  * @param {string} [props.status] - candidate | eligible | follow-up | ineligible | not-registered | off-study | on-study | on-study-intervention | on-study-observation | pending-on-study | potential-candidate | screening | withdrawn
  * @param {Period} [props.period] - Start and end of participation
  * @param {Reference} [props.study] - Study subject is part of
  * @param {Reference} [props.individual] - Who is part of study
  * @param {string} [props.assignedArm] - What path should be followed
  * @param {string} [props.actualArm] - What path was followed
  * @param {Reference} [props.consent] - Agreement to participate in study
  */
export function researchSubject(type: "ResearchSubject", props: ResearchSubject_Props);

export function researchSubject(props: ResearchSubject_Props);

export function researchSubject(type: any, props?: any) {
    const mappings = {
        "ResearchSubject": build_ResearchSubject
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "ResearchSubject";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a RiskAssessment resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {Identifier} [props.identifier] - Unique identifier for the assessment
  * @param {Reference} [props.basedOn] - Request fulfilled by this assessment
  * @param {Reference} [props.parent] - Part of this occurrence
  * @param {string} [props.status] - registered | preliminary | final | amended +
  * @param {CodeableConcept} [props.method] - Evaluation mechanism
  * @param {CodeableConcept} [props.code] - Type of assessment
  * @param {Reference} [props.subject] - Who/what does assessment apply to?
  * @param {Reference} [props.encounter] - Where was assessment performed?
  * @param {dateTime|Period} [props.occurrence] - When was assessment made?
  * @param {Reference} [props.condition] - Condition assessed
  * @param {Reference} [props.performer] - Who did assessment?
  * @param {CodeableConcept} [props.reasonCode] - Why the assessment was necessary?
  * @param {Reference} [props.reasonReference] - Why the assessment was necessary?
  * @param {Reference} [props.basis] - Information used in assessment
  * @param {BackboneElement} [props.prediction] - Outcome predicted
  * @param {string} [props.mitigation] - How to reduce risk
  * @param {Annotation} [props.note] - Comments on the risk assessment
  */
export function riskAssessment(type: "RiskAssessment", props: RiskAssessment_Props);

export function riskAssessment(props: RiskAssessment_Props);

export function riskAssessment(type: any, props?: any) {
    const mappings = {
        "RiskAssessment": build_RiskAssessment
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "RiskAssessment";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a Schedule resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {Identifier} [props.identifier] - External Ids for this item
  * @param {boolean} [props.active] - Whether this schedule is in active use
  * @param {CodeableConcept} [props.serviceCategory] - High-level category
  * @param {CodeableConcept} [props.serviceType] - Specific service
  * @param {CodeableConcept} [props.specialty] - Type of specialty needed
  * @param {Reference} [props.actor] - Resource(s) that availability information is being provided for
  * @param {Period} [props.planningHorizon] - Period of time covered by schedule
  * @param {string} [props.comment] - Comments on availability
  */
export function schedule(type: "Schedule", props: Schedule_Props);

export function schedule(props: Schedule_Props);

export function schedule(type: any, props?: any) {
    const mappings = {
        "Schedule": build_Schedule
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "Schedule";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a ServiceRequest resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {Identifier} [props.identifier] - Identifiers assigned to this order
  * @param {canonical} [props.instantiatesCanonical] - Instantiates FHIR protocol or definition
  * @param {string} [props.instantiatesUri] - Instantiates external protocol or definition
  * @param {Reference} [props.basedOn] - What request fulfills
  * @param {Reference} [props.replaces] - What request replaces
  * @param {Identifier} [props.requisition] - Composite Request ID
  * @param {string} [props.status] - draft | active | on-hold | revoked | completed | entered-in-error | unknown
  * @param {string} [props.intent] - proposal | plan | directive | order | original-order | reflex-order | filler-order | instance-order | option
  * @param {CodeableConcept} [props.category] - Classification of service
  * @param {string} [props.priority] - routine | urgent | asap | stat
  * @param {boolean} [props.doNotPerform] - True if service/procedure should not be performed
  * @param {CodeableConcept} [props.code] - What is being requested/ordered
  * @param {CodeableConcept} [props.orderDetail] - Additional order information
  * @param {Quantity|Ratio|Range} [props.quantity] - Service amount
  * @param {Reference} [props.subject] - Individual or Entity the service is ordered for
  * @param {Reference} [props.encounter] - Encounter in which the request was created
  * @param {dateTime|Period|Timing} [props.occurrence] - When service should occur
  * @param {boolean|CodeableConcept} [props.asNeeded] - Preconditions for service
  * @param {dateTime} [props.authoredOn] - Date request signed
  * @param {Reference} [props.requester] - Who/what is requesting service
  * @param {CodeableConcept} [props.performerType] - Performer role
  * @param {Reference} [props.performer] - Requested performer
  * @param {CodeableConcept} [props.locationCode] - Requested location
  * @param {Reference} [props.locationReference] - Requested location
  * @param {CodeableConcept} [props.reasonCode] - Explanation/Justification for procedure or service
  * @param {Reference} [props.reasonReference] - Explanation/Justification for service or service
  * @param {Reference} [props.insurance] - Associated insurance coverage
  * @param {Reference} [props.supportingInfo] - Additional clinical information
  * @param {Reference} [props.specimen] - Procedure Samples
  * @param {CodeableConcept} [props.bodySite] - Location on Body
  * @param {Annotation} [props.note] - Comments
  * @param {string} [props.patientInstruction] - Patient or consumer-oriented instructions
  * @param {Reference} [props.relevantHistory] - Request provenance
  */
export function serviceRequest(type: "ServiceRequest", props: ServiceRequest_Props);

export function serviceRequest(props: ServiceRequest_Props);

export function serviceRequest(type: any, props?: any) {
    const mappings = {
        "ServiceRequest": build_ServiceRequest
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "ServiceRequest";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a Slot resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {Identifier} [props.identifier] - External Ids for this item
  * @param {CodeableConcept} [props.serviceCategory] - A broad categorization of the service that is to be performed during this appointment
  * @param {CodeableConcept} [props.serviceType] - The type of appointments that can be booked into this slot (ideally this would be an identifiable service - which is at a location, rather than the location itself). If provided then this overrides the value provided on the availability resource
  * @param {CodeableConcept} [props.specialty] - The specialty of a practitioner that would be required to perform the service requested in this appointment
  * @param {CodeableConcept} [props.appointmentType] - The style of appointment or patient that may be booked in the slot (not service type)
  * @param {Reference} [props.schedule] - The schedule resource that this slot defines an interval of status information
  * @param {string} [props.status] - busy | free | busy-unavailable | busy-tentative | entered-in-error
  * @param {instant} [props.start] - Date/Time that the slot is to begin
  * @param {instant} [props.end] - Date/Time that the slot is to conclude
  * @param {boolean} [props.overbooked] - This slot has already been overbooked, appointments are unlikely to be accepted for this time
  * @param {string} [props.comment] - Comments on the slot to describe any extended information. Such as custom constraints on the slot
  */
export function slot(type: "Slot", props: Slot_Props);

export function slot(props: Slot_Props);

export function slot(type: any, props?: any) {
    const mappings = {
        "Slot": build_Slot
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "Slot";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a Specimen resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {Identifier} [props.identifier] - External Identifier
  * @param {Identifier} [props.accessionIdentifier] - Identifier assigned by the lab
  * @param {string} [props.status] - available | unavailable | unsatisfactory | entered-in-error
  * @param {CodeableConcept} [props.type] - Kind of material that forms the specimen
  * @param {Reference} [props.subject] - Where the specimen came from. This may be from patient(s), from a location (e.g., the source of an environmental sample), or a sampling of a substance or a device
  * @param {dateTime} [props.receivedTime] - The time when specimen was received for processing
  * @param {Reference} [props.parent] - Specimen from which this specimen originated
  * @param {Reference} [props.request] - Why the specimen was collected
  * @param {BackboneElement} [props.collection] - Collection details
  * @param {BackboneElement} [props.processing] - Processing and processing step details
  * @param {BackboneElement} [props.container] - Direct container of specimen (tube/slide, etc.)
  * @param {CodeableConcept} [props.condition] - State of the specimen
  * @param {Annotation} [props.note] - Comments
  */
export function specimen(type: "Specimen", props: Specimen_Props);

export function specimen(props: Specimen_Props);

export function specimen(type: any, props?: any) {
    const mappings = {
        "Specimen": build_Specimen
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "Specimen";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a SpecimenDefinition resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {Identifier} [props.identifier] - Business identifier of a kind of specimen
  * @param {CodeableConcept} [props.typeCollected] - Kind of material to collect
  * @param {CodeableConcept} [props.patientPreparation] - Patient preparation for collection
  * @param {string} [props.timeAspect] - Time aspect for collection
  * @param {CodeableConcept} [props.collection] - Specimen collection procedure
  * @param {BackboneElement} [props.typeTested] - Specimen in container intended for testing by lab
  */
export function specimenDefinition(type: "SpecimenDefinition", props: SpecimenDefinition_Props);

export function specimenDefinition(props: SpecimenDefinition_Props);

export function specimenDefinition(type: any, props?: any) {
    const mappings = {
        "SpecimenDefinition": build_SpecimenDefinition
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "SpecimenDefinition";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a Substance resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {Identifier} [props.identifier] - Unique identifier
  * @param {string} [props.status] - active | inactive | entered-in-error
  * @param {CodeableConcept} [props.category] - What class/type of substance this is
  * @param {CodeableConcept} [props.code] - What substance this is
  * @param {string} [props.description] - Textual description of the substance, comments
  * @param {BackboneElement} [props.instance] - If this describes a specific package/container of the substance
  * @param {BackboneElement} [props.ingredient] - Composition information about the substance
  */
export function substance(type: "Substance", props: Substance_Props);

export function substance(props: Substance_Props);

export function substance(type: any, props?: any) {
    const mappings = {
        "Substance": build_Substance
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "Substance";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a SubstanceDefinition resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {Identifier} [props.identifier] - Identifier by which this substance is known
  * @param {string} [props.version] - A business level version identifier of the substance
  * @param {CodeableConcept} [props.status] - Status of substance within the catalogue e.g. active, retired
  * @param {CodeableConcept} [props.classification] - A categorization, high level e.g. polymer or nucleic acid, or food, chemical, biological, or lower e.g. polymer linear or branch chain, or type of impurity
  * @param {CodeableConcept} [props.domain] - If the substance applies to human or veterinary use
  * @param {CodeableConcept} [props.grade] - The quality standard, established benchmark, to which substance complies (e.g. USP/NF, BP)
  * @param {markdown} [props.description] - Textual description of the substance
  * @param {Reference} [props.informationSource] - Supporting literature
  * @param {Annotation} [props.note] - Textual comment about the substance's catalogue or registry record
  * @param {Reference} [props.manufacturer] - The entity that creates, makes, produces or fabricates the substance
  * @param {Reference} [props.supplier] - An entity that is the source for the substance. It may be different from the manufacturer
  * @param {BackboneElement} [props.moiety] - Moiety, for structural modifications
  * @param {BackboneElement} [props.property] - General specifications for this substance
  * @param {BackboneElement} [props.molecularWeight] - The molecular weight or weight range
  * @param {BackboneElement} [props.structure] - Structural information
  * @param {BackboneElement} [props.code] - Codes associated with the substance
  * @param {BackboneElement} [props.name] - Names applicable to this substance
  * @param {BackboneElement} [props.relationship] - A link between this substance and another
  * @param {BackboneElement} [props.sourceMaterial] - Material or taxonomic/anatomical source
  */
export function substanceDefinition(type: "SubstanceDefinition", props: SubstanceDefinition_Props);

export function substanceDefinition(props: SubstanceDefinition_Props);

export function substanceDefinition(type: any, props?: any) {
    const mappings = {
        "SubstanceDefinition": build_SubstanceDefinition
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "SubstanceDefinition";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a SupplyDelivery resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {Identifier} [props.identifier] - External identifier
  * @param {Reference} [props.basedOn] - Fulfills plan, proposal or order
  * @param {Reference} [props.partOf] - Part of referenced event
  * @param {string} [props.status] - in-progress | completed | abandoned | entered-in-error
  * @param {Reference} [props.patient] - Patient for whom the item is supplied
  * @param {CodeableConcept} [props.type] - Category of dispense event
  * @param {BackboneElement} [props.suppliedItem] - The item that is delivered or supplied
  * @param {dateTime|Period|Timing} [props.occurrence] - When event occurred
  * @param {Reference} [props.supplier] - Dispenser
  * @param {Reference} [props.destination] - Where the Supply was sent
  * @param {Reference} [props.receiver] - Who collected the Supply
  */
export function supplyDelivery(type: "SupplyDelivery", props: SupplyDelivery_Props);

export function supplyDelivery(props: SupplyDelivery_Props);

export function supplyDelivery(type: any, props?: any) {
    const mappings = {
        "SupplyDelivery": build_SupplyDelivery
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "SupplyDelivery";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a SupplyRequest resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {Identifier} [props.identifier] - Business Identifier for SupplyRequest
  * @param {string} [props.status] - draft | active | suspended +
  * @param {CodeableConcept} [props.category] - The kind of supply (central, non-stock, etc.)
  * @param {string} [props.priority] - routine | urgent | asap | stat
  * @param {CodeableConcept|Reference} [props.item] - Medication, Substance, or Device requested to be supplied
  * @param {Quantity} [props.quantity] - The requested amount of the item indicated
  * @param {BackboneElement} [props.parameter] - Ordered item details
  * @param {dateTime|Period|Timing} [props.occurrence] - When the request should be fulfilled
  * @param {dateTime} [props.authoredOn] - When the request was made
  * @param {Reference} [props.requester] - Individual making the request
  * @param {Reference} [props.supplier] - Who is intended to fulfill the request
  * @param {CodeableConcept} [props.reasonCode] - The reason why the supply item was requested
  * @param {Reference} [props.reasonReference] - The reason why the supply item was requested
  * @param {Reference} [props.deliverFrom] - The origin of the supply
  * @param {Reference} [props.deliverTo] - The destination of the supply
  */
export function supplyRequest(type: "SupplyRequest", props: SupplyRequest_Props);

export function supplyRequest(props: SupplyRequest_Props);

export function supplyRequest(type: any, props?: any) {
    const mappings = {
        "SupplyRequest": build_SupplyRequest
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "SupplyRequest";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a Task resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {Identifier} [props.identifier] - Task Instance Identifier
  * @param {canonical} [props.instantiatesCanonical] - Formal definition of task
  * @param {string} [props.instantiatesUri] - Formal definition of task
  * @param {Reference} [props.basedOn] - Request fulfilled by this task
  * @param {Identifier} [props.groupIdentifier] - Requisition or grouper id
  * @param {Reference} [props.partOf] - Composite task
  * @param {string} [props.status] - draft | requested | received | accepted | +
  * @param {CodeableConcept} [props.statusReason] - Reason for current status
  * @param {CodeableConcept} [props.businessStatus] - E.g. "Specimen collected", "IV prepped"
  * @param {string} [props.intent] - unknown | proposal | plan | order | original-order | reflex-order | filler-order | instance-order | option
  * @param {string} [props.priority] - routine | urgent | asap | stat
  * @param {CodeableConcept} [props.code] - Task Type
  * @param {string} [props.description] - Human-readable explanation of task
  * @param {Reference} [props.focus] - What task is acting on
  * @param {Reference} [props.for] - Beneficiary of the Task
  * @param {Reference} [props.encounter] - Healthcare event during which this task originated
  * @param {Period} [props.executionPeriod] - Start and end time of execution
  * @param {dateTime} [props.authoredOn] - Task Creation Date
  * @param {dateTime} [props.lastModified] - Task Last Modified Date
  * @param {Reference} [props.requester] - Who is asking for task to be done
  * @param {CodeableConcept} [props.performerType] - Requested performer
  * @param {Reference} [props.owner] - Responsible individual
  * @param {Reference} [props.location] - Where task occurs
  * @param {CodeableConcept} [props.reasonCode] - Why task is needed
  * @param {Reference} [props.reasonReference] - Why task is needed
  * @param {Reference} [props.insurance] - Associated insurance coverage
  * @param {Annotation} [props.note] - Comments made about the task
  * @param {Reference} [props.relevantHistory] - Key events in history of the Task
  * @param {BackboneElement} [props.restriction] - Constraints on fulfillment tasks
  * @param {BackboneElement} [props.input] - Information used to perform task
  * @param {BackboneElement} [props.output] - Information produced as part of task
  */
export function task(type: "Task", props: Task_Props);

export function task(props: Task_Props);

export function task(type: any, props?: any) {
    const mappings = {
        "Task": build_Task
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "Task";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a TestReport resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {Identifier} [props.identifier] - External identifier
  * @param {string} [props.name] - Informal name of the executed TestScript
  * @param {string} [props.status] - completed | in-progress | waiting | stopped | entered-in-error
  * @param {Reference} [props.testScript] - Reference to the  version-specific TestScript that was executed to produce this TestReport
  * @param {string} [props.result] - pass | fail | pending
  * @param {decimal} [props.score] - The final score (percentage of tests passed) resulting from the execution of the TestScript
  * @param {string} [props.tester] - Name of the tester producing this report (Organization or individual)
  * @param {dateTime} [props.issued] - When the TestScript was executed and this TestReport was generated
  * @param {BackboneElement} [props.participant] - A participant in the test execution, either the execution engine, a client, or a server
  * @param {BackboneElement} [props.setup] - The results of the series of required setup operations before the tests were executed
  * @param {BackboneElement} [props.test] - A test executed from the test script
  * @param {BackboneElement} [props.teardown] - The results of running the series of required clean up steps
  */
export function testReport(type: "TestReport", props: TestReport_Props);

export function testReport(props: TestReport_Props);

export function testReport(type: any, props?: any) {
    const mappings = {
        "TestReport": build_TestReport
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "TestReport";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a VerificationResult resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {Reference} [props.target] - A resource that was validated
  * @param {string} [props.targetLocation] - The fhirpath location(s) within the resource that was validated
  * @param {CodeableConcept} [props.need] - none | initial | periodic
  * @param {string} [props.status] - attested | validated | in-process | req-revalid | val-fail | reval-fail
  * @param {dateTime} [props.statusDate] - When the validation status was updated
  * @param {CodeableConcept} [props.validationType] - nothing | primary | multiple
  * @param {CodeableConcept} [props.validationProcess] - The primary process by which the target is validated (edit check; value set; primary source; multiple sources; standalone; in context)
  * @param {Timing} [props.frequency] - Frequency of revalidation
  * @param {dateTime} [props.lastPerformed] - The date/time validation was last completed (including failed validations)
  * @param {date} [props.nextScheduled] - The date when target is next validated, if appropriate
  * @param {CodeableConcept} [props.failureAction] - fatal | warn | rec-only | none
  * @param {BackboneElement} [props.primarySource] - Information about the primary source(s) involved in validation
  * @param {BackboneElement} [props.attestation] - Information about the entity attesting to information
  * @param {BackboneElement} [props.validator] - Information about the entity validating information
  */
export function verificationResult(type: "VerificationResult", props: VerificationResult_Props);

export function verificationResult(props: VerificationResult_Props);

export function verificationResult(type: any, props?: any) {
    const mappings = {
        "VerificationResult": build_VerificationResult
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "VerificationResult";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}

/**
  * Create a VisionPrescription resource.
  * @public
  * @function
  * @param {object} props - Properties to apply to the resource (includes common and custom properties).
  * @param {Identifier} [props.identifier] - Business Identifier for vision prescription
  * @param {string} [props.status] - active | cancelled | draft | entered-in-error
  * @param {dateTime} [props.created] - Response creation date
  * @param {Reference} [props.patient] - Who prescription is for
  * @param {Reference} [props.encounter] - Created during encounter / admission / stay
  * @param {dateTime} [props.dateWritten] - When prescription was authorized
  * @param {Reference} [props.prescriber] - Who authorized the vision prescription
  * @param {BackboneElement} [props.lensSpecification] - Vision lens authorization
  */
export function visionPrescription(type: "VisionPrescription", props: VisionPrescription_Props);

export function visionPrescription(props: VisionPrescription_Props);

export function visionPrescription(type: any, props?: any) {
    const mappings = {
        "VisionPrescription": build_VisionPrescription
    };

    // Handle optional type parameter
    if (typeof type !== "string") {
      props = type;
      type = "VisionPrescription";
    }
    if (type in mappings) {
        return mappings[type](props)
    }
    throw new Error(`Error: profile "${type}" not recognised`)
}
